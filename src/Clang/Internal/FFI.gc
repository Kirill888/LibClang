{-# OPTIONS_GHC -w #-}
{-# LANGUAGE ConstraintKinds #-}
{-# LANGUAGE EmptyDataDecls #-}
{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE ForeignFunctionInterface #-}
{-# LANGUAGE TupleSections #-}
{-# LANGUAGE TypeFamilies #-}

module Clang.Internal.FFI
( Index
, createIndex
, GlobalOptFlags(..)
, globalOpt_ThreadBackgroundPriorityForAll
, cXIndex_setGlobalOptions
, cXIndex_getGlobalOptions
, TranslationUnit
, UnsavedFile
, unsavedFilename
, unsavedContents
, newUnsavedFile
, updateUnsavedContents
, AvailabilityKind(..)
, CXString
, getString
, getByteString
, unsafeGetByteString
, getStringHash
, File(..)
, getFileHash
, getFileName
, getFileTime
, getFile
, SourceLocation
, getNullLocation
, equalLocations
, getLocation
, getLocationForOffset
, location_isInSystemHeader
, location_isFromMainFile
, SourceRange
, getNullRange
, getRange
, equalRanges
, range_isNull
, getExpansionLocation
, getPresumedLocation
, getSpellingLocation
, getFileLocation
, getRangeStart
, getRangeEnd
, DiagnosticSeverity(..)
, Diagnostic
, getNumDiagnostics
, getDiagnostic
, DiagnosticDisplayOptions(..)
, formatDiagnostic
, defaultDiagnosticDisplayOptions
, getDiagnosticSeverity
, getDiagnosticLocation
, getDiagnosticSpelling
, getDiagnosticOption
, getDiagnosticCategory
, getDiagnosticCategoryText
, getDiagnosticNumRanges
, getDiagnosticRange
, getDiagnosticNumFixIts
, getDiagnosticFixIt
, getTranslationUnitSpelling
, createTranslationUnitFromSourceFile
, createTranslationUnit
, TranslationUnitFlags(..)
, defaultEditingTranslationUnitOptions
, parseTranslationUnit
, setClangResourcesPath 
, SaveTranslationUnitFlags(..)
, defaultSaveOptions
, saveTranslationUnit
, ReparseFlags(..)
, defaultReparseOptions
, reparseTranslationUnit
, CursorKind(..)
, cursor_FirstDecl
, cursor_LastDecl
, cursor_FirstRef
, cursor_LastRef
, cursor_FirstInvalid
, cursor_LastInvalid
, cursor_FirstExpr
, cursor_LastExpr
, cursor_FirstStmt
, cursor_LastStmt
, cursor_FirstAttr
, cursor_LastAttr
, cursor_FirstPreprocessing
, cursor_LastPreprocessing
, cursor_FirstExtraDecl
, cursor_LastExtraDecl
, cursor_GCCAsmStmt
, cursor_MacroInstantiation
, Comment(..)
, Cursor
, getNullCursor
, getTranslationUnitCursor
, cursor_isNull
, hashCursor
, getCursorKind
, isDeclaration
, isReference
, isExpression
, isStatement
, isAttribute
, isInvalid
, isTranslationUnit
, isPreprocessing
, isUnexposed
, LinkageKind(..)
, getCursorLinkage
, getCursorAvailability
, LanguageKind(..)
, getCursorLanguage
, cursor_getTranslationUnit
, CursorSet
, createCXCursorSet
, cXCursorSet_contains
, cXCursorSet_insert
, getCursorSemanticParent
, getCursorLexicalParent
, getOverriddenCursors
, getIncludedFile
, getCursor
, getCursorLocation
, getCursorSpellingLocation
, getCursorExtent
, TypeKind(..)
, type_FirstBuiltin
, type_LastBuiltin
, CallingConv(..)
, Type
, getTypeKind
, getCursorType
, getTypeSpelling
, getTypedefDeclUnderlyingType
, getEnumDeclIntegerType
, getEnumConstantDeclValue
, getEnumConstantDeclUnsignedValue
, getFieldDeclBitWidth
, cursor_getNumArguments
, cursor_getArgument
, equalTypes
, getCanonicalType
, isConstQualifiedType
, isVolatileQualifiedType
, isRestrictQualifiedType
, getPointeeType
, getTypeDeclaration
, getDeclObjCTypeEncoding
, getTypeKindSpelling
, getFunctionTypeCallingConv
, getResultType
, getNumArgTypes
, getArgType
, isFunctionTypeVariadic
, getCursorResultType
, isPODType
, getElementType
, getNumElements
, getArrayElementType
, getArraySize
, TypeLayoutError(..)
, type_getAlignOf
, type_getClassType
, type_getSizeOf
, type_getOffsetOf
, RefQualifierKind(..)
, type_getCXXRefQualifier
, isBitField
, isVirtualBase
, CXXAccessSpecifier(..)
, getCXXAccessSpecifier
, getNumOverloadedDecls
, getOverloadedDecl
, getIBOutletCollectionType
, CursorList
, getChildren
, getDescendants
, ParentedCursor(..)
, ParentedCursorList
, getParentedDescendants
, getCursorUSR
, constructUSR_ObjCClass
, constructUSR_ObjCCategory
, constructUSR_ObjCProtocol
, constructUSR_ObjCIvar
, constructUSR_ObjCMethod
, constructUSR_ObjCProperty
, getCursorSpelling
, cursor_getSpellingNameRange
, getCursorDisplayName
, getCursorReferenced
, getCursorDefinition
, isCursorDefinition
, cursor_isDynamicCall
, getCanonicalCursor
, cursor_getObjCSelectorIndex
, cursor_getReceiverType
, ObjCPropertyAttrKind(..)
, cursor_getObjCPropertyAttributes
, ObjCDeclQualifierKind(..)
, cursor_getObjCDeclQualifiers
, cursor_isObjCOptional
, cursor_isVariadic
, cursor_getCommentRange
, cursor_getRawCommentText
, cursor_getBriefCommentText
, cursor_getParsedComment
, Module(..)
, cursor_getModule
, module_getASTFile
, module_getParent
, module_getName
, module_getFullName
, module_getNumTopLevelHeaders
, module_getTopLevelHeader
, cXXMethod_isPureVirtual
, cXXMethod_isStatic
, cXXMethod_isVirtual
, getTemplateCursorKind
, getSpecializedCursorTemplate
, CommentKind(..)
, CommentInlineCommandRenderKind(..)
, CommentParamPassDirection(..)
, comment_getKind
, comment_getNumChildren
, comment_getChild
, comment_isWhitespace
, inlineContentComment_hasTrailingNewline
, textComment_getText
, inlineCommandComment_getCommandName
, inlineCommandComment_getRenderKind 
, inlineCommandComment_getNumArgs 
, inlineCommandComment_getArgText 
, hTMLTagComment_getTagName
, hTMLStartTagComment_isSelfClosing
, hTMLStartTag_getNumAttrs
, hTMLStartTag_getAttrName
, hTMLStartTag_getAttrValue
, blockCommandComment_getCommandName
, blockCommandComment_getNumArgs
, blockCommandComment_getArgText
, blockCommandComment_getParagraph
, paramCommandComment_getParamName
, paramCommandComment_isParamIndexValid
, paramCommandComment_getParamIndex
, paramCommandComment_isDirectionExplicit
, paramCommandComment_getDirection
, tParamCommandComment_getParamName
, tParamCommandComment_isParamPositionValid
, tParamCommandComment_getDepth
, tParamCommandComment_getIndex
, verbatimBlockLineComment_getText
, verbatimLineComment_getText
, hTMLTagComment_getAsString
, fullComment_getAsHTML
, fullComment_getAsXML 
, TokenKind(..)
, Token
, TokenList
, getTokenKind
, getTokenSpelling
, getTokenLocation
, getTokenExtent
, tokenize
, annotateTokens
, getCursorKindSpelling
, enableStackTraces
, CompletionString
, CompletionResult
, CompletionChunkKind(..)
, getCompletionChunkKind
, getCompletionChunkText
, getCompletionChunkCompletionString
, getNumCompletionChunks
, getCompletionPriority
, getCompletionAvailability
, getCompletionNumAnnotations
, getCompletionAnnotation
, getCompletionParent
, getCompletionBriefComment
, getCursorCompletionString
, CodeCompleteFlags(..)
, defaultCodeCompleteOptions
, CodeCompleteResults
, codeCompleteAt
, sortCodeCompletionResults
, codeCompleteGetNumDiagnostics
, codeCompleteGetDiagnostic
, CompletionContext(..)
, codeCompleteGetContexts
, codeCompleteGetContainerKind
, codeCompleteGetContainerUSR
, codeCompleteGetObjCSelector
, getClangVersion
, toggleCrashRecovery
, Inclusion(..)
, InclusionList
, getInclusions
) where

import Control.Applicative ((<$>), (<*>))
import Control.Monad (when)
import Control.Monad.Trans
import qualified Data.ByteString as B
import qualified Data.ByteString.Unsafe as BU
import Data.Hashable
import qualified Data.Vector as DV
import qualified Data.Vector.Generic as DVG
import qualified Data.Vector.Storable as DVS
import qualified Data.Vector.Storable.Mutable as DVSM
import Data.Word
import Foreign.C
import Foreign.ForeignPtr.Unsafe (unsafeForeignPtrToPtr)
import Foreign.GreenCard
import Unsafe.Coerce (unsafeCoerce)  -- With GHC 7.8 we can use the safer 'coerce'.

import Clang.Internal.BitFlags
import Clang.Internal.FFIConstants
import Clang.Internal.Monad

%#include <inttypes.h>
%#include <stdlib.h>
%#include <stddef.h>
%#include <clang-c/Index.h>
%#include <stdio.h>
%#include "visitors.h"

%prefix CX
%prefix CX_
%prefix clang_

{-
LibClang uses two strategies to create safe, deterministic
bindings.

First, all types that either represent resources managed on the C side
(for example, TranslationUnit and CXString) or contain pointers into
those resources (for example, Cursor) are tagged with an ST-like
universally quantified phantom type parameter. This prevents them from
being used outside of the scope in which they were allocated. This is
particularly important for libclang, which uses an arena allocator to
store much of its data; preventing resources from leaking outside
their proper scope is critical to making this safe.

Second, all operations that allocate a resource that later
needs to be freed are wrapped in a type-specific 'register'
function. An example is registerCXString. This function registers a
cleanup action with the underlying ClangT monad, which is essentially
just ResourceT in disguise. This not only provides safety, but it also
enforces prompt finalization of resources which can significantly
increase performance by keeping the working set of user programs down.

There are a few different patterns for the FFI code, depending on what
kind of value the libclang function we want to wrap returns.

If it returns a pure value (say an Int), then we don't need to do
anything special. The greencard-generated function will have a return
type of IO Int, and the user-facing wrapper function will use liftIO
to call it.

If it returns a value that doesn't represent a newly allocated
resource, but does need the phantom type parameter (because it
contains a pointer into some other resource, generally), then we
generally pass a Proxy value with a type parameter that we'll use to
tag the return type. This has no runtime cost. The user-facing wrapper
function still needs to call liftIO.

For values that DO represent a newly allocated resource, we need to
call the appropriate 'register' function. This function will return a
value in the ClangT monad, so user-facing wrapper functions don't need
to use liftIO or Proxy in this case. It's the convention to use '()' for the
phantom type parameter returned from the greencard-generated function,
and allow the 'register' function to coerce the value to the correct
type. This way we can distinguish values that need to be registered
from other values: if a value's phantom type parameter is '()', it
needs to be registered, and it won't typecheck as the return value of
a user-facing wrapper function.

It's important to keep in mind that it should be legal to use values
from enclosing scopes in an inner scope created by clangScope. In
practice, this means that the phantom type parameters used by each
argument to a function should be distinct, and they should all be
distinct from the phantom type parameter used in the return value.
Of course, this doesn't apply to the Proxy parameter, which must
always have the same phantom type parameter as the return value.
-}

-- Used with the Proxy type in Clang.Internal.Monad.
%dis proxy = <id/id>

-- Marshalling utility functions.
fromCInt :: Num b => CInt -> b
fromCInt = fromIntegral

toCInt :: Integral a => a -> CInt
toCInt = fromIntegral

-- typedef void *CXIndex;
newtype Index s = Index { unIndex :: Ptr () }

mkIndex :: Ptr () -> Index ()
mkIndex = Index

%dis index i = <unIndex/mkIndex> (ptr i)

-- CXIndex clang_createIndex(int excludeDeclarationsFromPCH, int displayDiagnostics);
%fun unsafe_createIndex :: Bool -> Bool -> IO (Index ())
%call (bool a) (bool b)
%code CXIndex r = clang_createIndex(a, b);
%result (index r)

createIndex :: ClangBase m => Bool -> Bool -> ClangT s m (Index s)
createIndex = (registerIndex .) . unsafe_createIndex

-- void clang_disposeIndex(CXIndex index);
%fun clang_disposeIndex :: Index s -> IO ()
%call (index i)
%code clang_disposeIndex(i);

registerIndex :: ClangBase m => IO (Index ()) -> ClangT s m (Index s)
registerIndex action = do
  (_, idx) <- clangAllocate (action >>= return . unsafeCoerce)
                            (\i -> disposeIndex i)
  return idx
{-# INLINEABLE registerIndex #-}

-- typedef enum {
--   CXGlobalOpt_None = 0x0,
--   CXGlobalOpt_ThreadBackgroundPriorityForIndexing = 0x1,
--   CXGlobalOpt_ThreadBackgroundPriorityForEditing = 0x2,
--   CXGlobalOpt_ThreadBackgroundPriorityForAll =
--       CXGlobalOpt_ThreadBackgroundPriorityForIndexing |
--       CXGlobalOpt_ThreadBackgroundPriorityForEditing
-- 
-- } CXGlobalOptFlags;

%enum GlobalOptFlags (Bounded, Enum, Eq, Ord, Read, Show) Int [CXGlobalOpt_None, CXGlobalOpt_ThreadBackgroundPriorityForIndexing, CXGlobalOpt_ThreadBackgroundPriorityForEditing]

instance BitFlags GlobalOptFlags where
  toBit GlobalOpt_None                                = 0x0
  toBit GlobalOpt_ThreadBackgroundPriorityForIndexing = 0x1
  toBit GlobalOpt_ThreadBackgroundPriorityForEditing  = 0x2

globalOpt_ThreadBackgroundPriorityForAll :: [GlobalOptFlags]
globalOpt_ThreadBackgroundPriorityForAll = [GlobalOpt_ThreadBackgroundPriorityForEditing,
                                            GlobalOpt_ThreadBackgroundPriorityForIndexing]

-- void clang_CXIndex_setGlobalOptions(CXIndex, unsigned options);
%fun clang_CXIndex_setGlobalOptions :: Index s -> Int -> IO ()
%call (index i) (int f)
%code clang_CXIndex_setGlobalOptions(i, f);

-- unsigned clang_CXIndex_getGlobalOptions(CXIndex);
%fun clang_CXIndex_getGlobalOptions :: Index s -> IO Int
%call (index i)
%code r = clang_CXIndex_getGlobalOptions(i);
%result (int r)

-- typedef struct CXTranslationUnitImpl *CXTranslationUnit;
newtype TranslationUnit s = TranslationUnit { unTranslationUnit :: (Ptr ()) }

mkTranslationUnit :: Ptr () -> TranslationUnit ()
mkTranslationUnit = TranslationUnit

-- void clang_disposeTranslationUnit(CXTranslationUnit);
%fun clang_disposeTranslationUnit :: TranslationUnit s -> IO ()
%call (translationUnit t)
%code clang_disposeTranslationUnit(t);

registerTranslationUnit :: ClangBase m => IO (TranslationUnit ())
                        -> ClangT s m (TranslationUnit s)
registerTranslationUnit action = do
  (_, tu) <- clangAllocate (action >>= return . unsafeCoerce)
                           (\t -> disposeTranslationUnit t)
  return tu
{-# INLINEABLE registerTranslationUnit #-}

%dis translationUnit t = <unTranslationUnit/mkTranslationUnit> (ptr t)

-- struct CXUnsavedFile {
--   const char* Filename;
--   const char* Contents;
--   unsigned long Length;
-- };
data UnsavedFile = UnsavedFile
  { _unsavedFilename :: !B.ByteString
  , _unsavedContents :: !B.ByteString
  } deriving (Eq, Show)

-- We maintain the invariant that _unsavedFilename is always
-- null-terminated. That's why we don't directly expose the record fields.
unsavedFilename :: UnsavedFile -> B.ByteString
unsavedFilename = _unsavedFilename

unsavedContents :: UnsavedFile -> B.ByteString
unsavedContents = _unsavedContents

newUnsavedFile :: B.ByteString -> B.ByteString -> UnsavedFile
newUnsavedFile f c = UnsavedFile (nullTerminate f) c

updateUnsavedContents :: UnsavedFile -> B.ByteString -> UnsavedFile
updateUnsavedContents uf c = UnsavedFile (unsavedFilename uf) c

-- TODO: Use BU.unsafeLast when we can use newer B.ByteString.
nullTerminate :: B.ByteString -> B.ByteString
nullTerminate bs
  | B.null bs      = B.singleton 0
  | B.last bs == 0 = bs
  | otherwise      = B.snoc bs 0

-- Functions which take a Vector UnsavedFile argument are implemented
-- internally in terms of this function, which temporarily allocates a
-- Vector CUnsavedFile holding the same data. (But does not copy the
-- string data itself.)
withUnsavedFiles :: DV.Vector UnsavedFile -> (Ptr CUnsavedFile -> Int -> IO a) -> IO a
withUnsavedFiles ufs f =
  withCUnsavedFiles ufs $ \cufs ->
    DVS.unsafeWith cufs $ \ptr ->
      f ptr (DVS.length cufs)

data CUnsavedFile = CUnsavedFile
  { cUnsavedFilename    :: CString
  , cUnsavedContents    :: CString
  , cUnsavedContentsLen :: CULong
  }

instance Storable CUnsavedFile where
    sizeOf _ = sizeOfCXUnsavedFile
    {-# INLINE sizeOf #-}

    alignment _ = alignOfCXUnsavedFile
    {-# INLINE alignment #-}

    peek p = do
      filename    <- peekByteOff p offsetCXUnsavedFileFilename
      contents    <- peekByteOff p offsetCXUnsavedFileContents
      contentsLen <- peekByteOff p offsetCXUnsavedFileContentsLen
      return $! CUnsavedFile filename contents contentsLen
    {-# INLINE peek #-}

    poke p (CUnsavedFile filename contents contentsLen) = do
      pokeByteOff p offsetCXUnsavedFileFilename filename
      pokeByteOff p offsetCXUnsavedFileContents contents
      pokeByteOff p offsetCXUnsavedFileContentsLen contentsLen
    {-# INLINE poke #-}
  

withCUnsavedFiles :: DV.Vector UnsavedFile -> (DVS.Vector CUnsavedFile -> IO a) -> IO a
withCUnsavedFiles ufs f = do
    let len = DV.length ufs
    v <- DVSM.new len
    go f v 0 len
  where
    go f v i len
      | i == len  = f =<< DVS.unsafeFreeze v
      | otherwise = do let uf = DV.unsafeIndex ufs i
                           ufFilename = unsavedFilename uf
                           ufContents = unsavedContents uf
                       BU.unsafeUseAsCString ufFilename $ \cufFilename ->
                         BU.unsafeUseAsCString ufContents $ \cufContents -> do
                           let contentsLen = fromIntegral $ B.length ufContents
                               cuf = CUnsavedFile cufFilename cufContents contentsLen
                           DVSM.write v i cuf
                           go f v (i + 1) len

%enum AvailabilityKind (Bounded, Enum, Eq, Ord, Read, Show) Int [CXAvailability_Available, CXAvailability_Deprecated, CXAvailability_NotAvailable, CXAvailability_NotAccessible]
-- enum CXAvailabilityKind {
--   CXAvailability_Available,
--   CXAvailability_Deprecated,
--   CXAvailability_NotAvailable,
--   CXAvailability_NotAccessible
-- };

-- typedef struct {
--   const void *data;
--   unsigned private_flags;
-- } CXString;
data CXString s = CXString !(Ptr ()) !Word32

registerCXString :: ClangBase m => IO (CXString ()) -> ClangT s m (CXString s)
registerCXString action = do
  (_, str) <- clangAllocate (action >>= return . unsafeCoerce)
                            (\(CXString d f) -> freeCXString d f)
  return str
{-# INLINEABLE registerCXString #-}

%C void freeCXString(void* data, unsigned flags) {
%    CXString str;
%    str.data = data;
%    str.private_flags = flags;
%    //printf("Called freeCXString for string [%s]\n", clang_getCString(str));
%    clang_disposeString(str);
%  }
foreign import ccall unsafe "FFI_stub_ffi.h freeCXString" freeCXString :: Ptr () -> Word32 -> IO ()

unmarshall_cxString :: Ptr () -> Word32 -> IO (CXString ())
unmarshall_cxString d f = return $ CXString d f

getString :: ClangBase m => CXString s' -> ClangT s m String
getString (CXString d f) = liftIO $ getCStringPtr d f >>= peekCString

getByteString :: ClangBase m => CXString s' -> ClangT s m B.ByteString
getByteString (CXString d f) = liftIO $ getCStringPtr d f >>= B.packCString

unsafeGetByteString :: ClangBase m => CXString s' -> ClangT s m B.ByteString
unsafeGetByteString (CXString d f) = liftIO $ getCStringPtr d f >>= BU.unsafePackCString

-- const char *clang_getCString(CXString string);
%fun clang_getCStringPtr :: Ptr () -> Word32 -> IO CString
%call (ptr d) (word32 f)
%code CXString str;
%     str.data = d;
%     str.private_flags = f;
%     r = (char*) clang_getCString(str);
%result (ptr r)

%dis word32 x    = %%Word32 ({HsWord32} x)
%dis word64 x    = %%Word64 ({HsWord64} x)

getStringHash :: CXString s -> WordPtr
getStringHash (CXString p _) = ptrToWordPtr p

-- typedef void *CXFile;
newtype File s = File { unFile :: Ptr () }
  deriving (Eq, Ord)

%dis file p = <unFile/File> (ptr p)

maybeFile :: File s' -> Maybe (File s)
maybeFile (File p) | p == nullPtr = Nothing
maybeFile f                       = Just (unsafeCoerce f)

unMaybeFile :: Maybe (File s') -> File s
unMaybeFile (Just f) = unsafeCoerce f
unMaybeFile Nothing  = File nullPtr

%dis maybe_file f = <unMaybeFile/maybeFile> (file f)

getFileHash :: File s -> WordPtr
getFileHash (File p) = ptrToWordPtr p

-- CXString clang_getFileName(CXFile SFile);
%fun unsafe_getFileName :: File s -> IO (CXString ())
%call (file x)
%code CXString out = clang_getFileName(x);
%     const void* outData = out.data;
%     unsigned outFlags = out.private_flags;
%result (cxString (ptr outData) (word32 outFlags))

getFileName :: ClangBase m => File s' -> ClangT s m (CXString s)
getFileName = registerCXString . unsafe_getFileName

-- time_t clang_getFileTime(CXFile SFile);
foreign import ccall unsafe "clang-c/Index.h clang_getFileTime" clang_getFileTime :: Ptr () -> IO CTime

getFileTime :: File s -> IO CTime
getFileTime (File ptr) = clang_getFileTime ptr

-- CXFile clang_getFile(CXTranslationUnit tu, const char *file_name);
%fun clang_getFile :: Proxy s -> TranslationUnit s' -> String -> IO (File s)
%call (proxy) (translationUnit t) (string s)
%code CXFile r = clang_getFile(t, s);
%result (file r)

-- typedef struct {
--   void *ptr_data[2];
--   unsigned int_data;
-- } CXSourceLocation;
data SourceLocation s = SourceLocation !(Ptr ()) !(Ptr ()) !Int
%dis sourceLocation p1 p2 d = SourceLocation (ptr p1) (ptr p2) (int d)

instance Storable (SourceLocation s) where
    sizeOf _ = sizeOfCXSourceLocation
    {-# INLINE sizeOf #-}

    alignment _ = alignOfCXSourceLocation
    {-# INLINE alignment #-}

    peek p = do
      let fromCUInt = fromIntegral :: Num b => CUInt -> b
      p1 <- peekByteOff p offsetCXSourceLocationP1
      p2 <- peekByteOff p offsetCXSourceLocationP2
      d <- fromCUInt <$> peekByteOff p offsetCXSourceLocationData
      return $! SourceLocation p1 p2 d
    {-# INLINE peek #-}

    poke p (SourceLocation p1 p2 d) = do
      let toCUInt = fromIntegral :: Integral a => a -> CUInt
      pokeByteOff p offsetCXSourceLocationP1 p1
      pokeByteOff p offsetCXSourceLocationP2 p2
      pokeByteOff p offsetCXSourceLocationData $ toCUInt d
    {-# INLINE poke #-}

-- typedef struct {
--   void *ptr_data[2];
--   unsigned begin_int_data;
--   unsigned end_int_data;
-- } CXSourceRange;
data SourceRange s = SourceRange !(Ptr ()) !(Ptr ()) !Int !Int
%dis sourceRange p1 p2 d1 d2 = SourceRange (ptr p1) (ptr p2) (int d1) (int d2)

-- CXSourceLocation clang_getNullLocation();
%fun clang_getNullLocation :: Proxy s -> IO (SourceLocation s)
%call (proxy)
%code CXSourceLocation r = clang_getNullLocation();
%result (sourceLocation {r.ptr_data[0]} {r.ptr_data[1]} {r.int_data})

-- unsigned clang_equalLocations(CXSourceLocation loc1, CXSourceLocation loc2);
%fun clang_equalLocations :: SourceLocation s -> SourceLocation s' -> IO Bool
%call (sourceLocation p1 p2 d) (sourceLocation p12 p22 d2)
%code CXSourceLocation l = {{p1, p2}, d};
%     CXSourceLocation m = {{p12, p22}, d2};
%result (bool {clang_equalLocations(l, m)})

-- CXSourceLocation clang_getLocation(CXTranslationUnit tu,
--                                                   CXFile file,
--                                                   unsigned line,
--                                                   unsigned column);
%fun clang_getLocation :: Proxy s -> TranslationUnit s' -> File s'' -> Int -> Int -> IO (SourceLocation s)
%call (proxy) (translationUnit t) (file f) (int i) (int j)
%code CXSourceLocation r = clang_getLocation((CXTranslationUnit)t, f, i, j);
%result (sourceLocation {r.ptr_data[0]} {r.ptr_data[1]} {r.int_data})

-- CXSourceLocation clang_getLocationForOffset(CXTranslationUnit tu,
--                                                            CXFile file,
--                                                            unsigned offset);
%fun clang_getLocationForOffset :: Proxy s -> TranslationUnit s' -> File s'' -> Int -> IO (SourceLocation s)
%call (proxy) (translationUnit t) (file f) (int i)
%code CXSourceLocation r = clang_getLocationForOffset((CXTranslationUnit)t, f, i);
%result (sourceLocation {r.ptr_data[0]} {r.ptr_data[1]} {r.int_data})

-- int clang_Location_isInSystemHeader(CXSourceLocation location);
%fun clang_Location_isInSystemHeader :: SourceLocation s -> IO Bool
%call (sourceLocation p1 p2 d)
%code CXSourceLocation l = {{p1, p2}, d};
%result (bool {clang_Location_isInSystemHeader(l)})

-- int clang_Location_isFromMainFile(CXSourceLocation location);
%fun clang_Location_isFromMainFile :: SourceLocation s -> IO Bool
%call (sourceLocation p1 p2 d)
%code CXSourceLocation l = {{p1, p2}, d};
%result (bool {clang_Location_isFromMainFile(l)})

-- CXSourceRange clang_getNullRange();
%fun clang_getNullRange :: Proxy s -> IO (SourceRange s)
%call (proxy)
%code CXSourceRange r = clang_getNullRange();
%result (sourceRange {r.ptr_data[0]} {r.ptr_data[1]} {r.begin_int_data} {r.end_int_data})

-- CXSourceRange clang_getRange(CXSourceLocation begin, CXSourceLocation end);
%fun clang_getRange :: Proxy s -> SourceLocation s' -> SourceLocation s'' -> IO (SourceRange s)
%call (proxy) (sourceLocation p1 p2 d) (sourceLocation p12 p22 d2)
%code CXSourceLocation l = {{p1, p2}, d};
%     CXSourceLocation m = {{p12, p22}, d2};
%     CXSourceRange r = clang_getRange(l, m);
%result (sourceRange {r.ptr_data[0]} {r.ptr_data[1]} {r.begin_int_data} {r.end_int_data})

-- unsigned clang_equalRanges(CXSourceRange range1, CXSourceRange range2);
%fun clang_equalRanges :: SourceRange s' -> SourceRange s'' -> IO Bool
%call (sourceRange p1 p2 d1 d2) (sourceRange p12 p22 d12 d22)
%code CXSourceRange r1 = {{p1, p2}, d1, d2};
%     CXSourceRange r2 = {{p12, p22}, d12, d22};
%     unsigned r = clang_equalRanges(r1, r2);
%result (bool r)

-- int clang_Range_isNull(CXSourceRange range);
%fun clang_Range_isNull :: SourceRange s -> IO Bool
%call (sourceRange p1 p2 d1 d2)
%code CXSourceRange r1 = {{p1, p2}, d1, d2};
%result (bool {clang_Range_isNull(r1)})

-- void clang_getExpansionLocation(CXSourceLocation location,
--                                 CXFile *file,
--                                 unsigned *line,
--                                 unsigned *column,
--                                 unsigned *offset);
%fun clang_getExpansionLocation :: Proxy s -> SourceLocation s' -> IO (Maybe (File s), Int, Int, Int)
%call (proxy) (sourceLocation p1 p2 d)
%code CXSourceLocation l = {{p1, p2}, d};
%     CXFile f;
%     unsigned ln, c, o;
%     clang_getExpansionLocation(l, &f, &ln, &c, &o);
%result ((maybe_file f), (int ln), (int c), (int o))

-- void clang_getPresumedLocation(CXSourceLocation location,
--                                CXString *filename,
--                                unsigned *line,
--                                unsigned *column);
%fun unsafe_getPresumedLocation :: SourceLocation s' -> IO (CXString (), Int, Int)
%call (sourceLocation p1 p2 d)
%code CXSourceLocation l = {{p1, p2}, d};
%     CXString f;
%     unsigned ln, c;
%     clang_getPresumedLocation(l, &f, &ln, &c);
%     const void* outData = f.data;
%     unsigned outFlags = f.private_flags;
%result ((cxString (ptr outData) (word32 outFlags)), (int ln), (int c))

getPresumedLocation :: ClangBase m => SourceLocation s' -> ClangT s m (CXString s, Int, Int)
getPresumedLocation l = do
  (f, ln, c) <- liftIO $ unsafe_getPresumedLocation l
  (,,) <$> registerCXString (return f) <*> return ln <*> return c

-- void clang_getSpellingLocation(CXSourceLocation location,
--                                CXFile *file,
--                                unsigned *line,
--                                unsigned *column,
--                                unsigned *offset);
%fun clang_getSpellingLocation :: Proxy s -> SourceLocation s' -> IO (Maybe (File s), Int, Int, Int)
%call (proxy) (sourceLocation p1 p2 d)
%code CXSourceLocation l = {{p1, p2}, d};
%     CXFile f;
%     unsigned ln, c, o;
%     clang_getSpellingLocation(l, &f, &ln, &c, &o);
%result ((maybe_file f), (int ln), (int c), (int o))

-- void clang_getFileLocation(CXSourceLocation location,
--                            CXFile *file,
--                            unsigned *line,
--                            unsigned *column,
--                            unsigned *offset);
%fun clang_getFileLocation :: Proxy s -> SourceLocation s' -> IO (Maybe (File s), Int, Int, Int)
%call (proxy) (sourceLocation p1 p2 d)
%code CXSourceLocation l = {{p1, p2}, d};
%     CXFile f;
%     unsigned ln, c, o;
%     clang_getFileLocation(l, &f, &ln, &c, &o);
%result ((maybe_file f), (int ln), (int c), (int o))

-- CXSourceLocation clang_getRangeStart(CXSourceRange range);
%fun clang_getRangeStart :: Proxy s -> SourceRange s' -> IO (SourceLocation s)
%call (proxy) (sourceRange p1 p2 d1 d2)
%code CXSourceRange a = {{p1, p2}, d1, d2};
%     CXSourceLocation r = clang_getRangeStart(a);
%result (sourceLocation {r.ptr_data[0]} {r.ptr_data[1]} {r.int_data})

-- CXSourceLocation clang_getRangeEnd(CXSourceRange range);
%fun clang_getRangeEnd :: Proxy s -> SourceRange s' -> IO (SourceLocation s)
%call (proxy) (sourceRange p1 p2 d1 d2)
%code CXSourceRange a = {{p1, p2}, d1, d2};
%     CXSourceLocation r = clang_getRangeEnd(a);
%result (sourceLocation {r.ptr_data[0]} {r.ptr_data[1]} {r.int_data})

-- enum CXDiagnosticSeverity {
--   CXDiagnostic_Ignored = 0,
--   CXDiagnostic_Note    = 1,
--   CXDiagnostic_Warning = 2,
--   CXDiagnostic_Error   = 3,
--   CXDiagnostic_Fatal   = 4
-- };
%enum DiagnosticSeverity (Bounded, Enum, Eq, Ord, Read, Show) Int [CXDiagnostic_Ignored, CXDiagnostic_Note, CXDiagnostic_Warning, CXDiagnostic_Error, CXDiagnostic_Fatal]

-- typedef void* CXDiagnostic;
newtype Diagnostic s = Diagnostic { unDiagnostic :: Ptr () }

mkDiagnostic :: Ptr () -> Diagnostic ()
mkDiagnostic = Diagnostic

-- void clang_disposeDiagnostic(CXDiagnostic);
%fun clang_disposeDiagnostic :: Diagnostic s -> IO ()
%call (diag d)
%code clang_disposeDiagnostic(d);

registerDiagnostic :: ClangBase m => IO (Diagnostic ()) -> ClangT s m (Diagnostic s)
registerDiagnostic action = do
  (_, idx) <- clangAllocate (action >>= return . unsafeCoerce)
                            (\i -> disposeDiagnostic i)
  return idx
{-# INLINEABLE registerDiagnostic #-}

%dis diag i = <unDiagnostic/mkDiagnostic> (ptr i)

-- unsigned clang_getNumDiagnostics(CXTranslationUnit Unit);
%fun clang_getNumDiagnostics :: TranslationUnit s -> IO Int
%call (translationUnit t)
%code unsigned r = clang_getNumDiagnostics((CXTranslationUnit)t);
%result (int r)

-- CXDiagnostic clang_getDiagnostic(CXTranslationUnit Unit, unsigned Index);
%fun unsafe_getDiagnostic :: TranslationUnit s -> Int -> IO (Diagnostic ())
%call (translationUnit t) (int i)
%code CXDiagnostic r = clang_getDiagnostic((CXTranslationUnit)t, i);
%result (diag r)

getDiagnostic :: ClangBase m => TranslationUnit s' -> Int -> ClangT s m (Diagnostic s)
getDiagnostic = (registerDiagnostic .) . unsafe_getDiagnostic

-- enum CXDiagnosticDisplayOptions {
--   CXDiagnostic_DisplaySourceLocation = 0x01,
--   CXDiagnostic_DisplayColumn = 0x02,
--   CXDiagnostic_DisplaySourceRanges = 0x04,
--   CXDiagnostic_DisplayOption = 0x08,
--   CXDiagnostic_DisplayCategoryId = 0x10,
--   CXDiagnostic_DisplayCategoryName = 0x20
-- };
%enum DiagnosticDisplayOptions (Bounded, Enum, Eq, Ord, Read, Show) Int [CXDiagnostic_DisplaySourceLocation,CXDiagnostic_DisplayColumn,CXDiagnostic_DisplaySourceRanges,  CXDiagnostic_DisplayOption,  CXDiagnostic_DisplayCategoryId,CXDiagnostic_DisplayCategoryName]

instance BitFlags DiagnosticDisplayOptions where
  toBit Diagnostic_DisplaySourceLocation = 0x1
  toBit Diagnostic_DisplayColumn         = 0x2
  toBit Diagnostic_DisplaySourceRanges   = 0x4
  toBit Diagnostic_DisplayOption         = 0x8
  toBit Diagnostic_DisplayCategoryId     = 0x10
  toBit Diagnostic_DisplayCategoryName   = 0x20

-- CXString clang_formatDiagnostic(CXDiagnostic Diagnostic, unsigned Options);
%fun unsafe_formatDiagnostic :: Diagnostic s -> Int -> IO (CXString ())
%call (diag d) (int i)
%code CXString out = clang_formatDiagnostic(d, i);
%     const void* outData = out.data;
%     unsigned outFlags = out.private_flags;
%result (cxString (ptr outData) (word32 outFlags))

formatDiagnostic :: ClangBase m => Diagnostic s' -> Int -> ClangT s m (CXString s)
formatDiagnostic = (registerCXString .) . unsafe_formatDiagnostic

-- unsigned clang_defaultDiagnosticDisplayOptions(void);
%fun clang_defaultDiagnosticDisplayOptions :: IO Int

-- clang_getDiagnosticSeverity(CXDiagnostic);
%fun clang_getDiagnosticSeverity :: Diagnostic s -> IO DiagnosticSeverity
%call (diag d)
%code enum CXDiagnosticSeverity s = clang_getDiagnosticSeverity(d);
%result (diagnosticSeverity s)

-- CXSourceLocation clang_getDiagnosticLocation(CXDiagnostic);
%fun clang_getDiagnosticLocation :: Proxy s -> Diagnostic s' -> IO (SourceLocation s)
%call (proxy) (diag d)
%code CXSourceLocation r = clang_getDiagnosticLocation(d);
%result (sourceLocation {r.ptr_data[0]} {r.ptr_data[1]} {r.int_data})

-- CXString clang_getDiagnosticSpelling(CXDiagnostic);
%fun unsafe_getDiagnosticSpelling :: Diagnostic s -> IO (CXString ())
%call (diag d)
%code CXString out = clang_getDiagnosticSpelling(d);
%     const void* outData = out.data;
%     unsigned outFlags = out.private_flags;
%result (cxString (ptr outData) (word32 outFlags))

getDiagnosticSpelling :: ClangBase m => Diagnostic s' -> ClangT s m (CXString s)
getDiagnosticSpelling = registerCXString . unsafe_getDiagnosticSpelling

-- CXString clang_getDiagnosticOption(CXDiagnostic Diag,
--                                                   CXString *Disable);
%fun unsafe_getDiagnosticOption :: Diagnostic s -> IO (CXString (), CXString ())
%call (diag d)
%code CXString a;
%     CXString out = clang_getDiagnosticOption(d, &a);
%     const void* aData = a.data;
%     unsigned aFlags = a.private_flags;
%     const void* outData = out.data;
%     unsigned outFlags = out.private_flags;
%result ((cxString (ptr outData) (word32 outFlags)), (cxString (ptr aData) (word32 aFlags)))

getDiagnosticOption :: ClangBase m => Diagnostic s' -> ClangT s m (CXString s, CXString s)
getDiagnosticOption d = do
  (a, b) <- liftIO $ unsafe_getDiagnosticOption d
  (,) <$> registerCXString (return a) <*> registerCXString (return b)

-- unsigned clang_getDiagnosticCategory(CXDiagnostic);
%fun clang_getDiagnosticCategory :: Diagnostic s -> IO Int
%call (diag d)
%code int c = clang_getDiagnosticCategory(d);
%result (int c)

-- CXString clang_getDiagnosticCategoryText(CXDiagnostic);
%fun unsafe_getDiagnosticCategoryText :: Diagnostic s -> IO (CXString ())
%call (diag d)
%code CXString out = clang_getDiagnosticCategoryText(d);
%     const void* outData = out.data;
%     unsigned outFlags = out.private_flags;
%result (cxString (ptr outData) (word32 outFlags))

getDiagnosticCategoryText :: ClangBase m => Diagnostic s' -> ClangT s m (CXString s)
getDiagnosticCategoryText = registerCXString . unsafe_getDiagnosticCategoryText

-- unsigned clang_getDiagnosticNumRanges(CXDiagnostic);
%fun clang_getDiagnosticNumRanges :: Diagnostic s -> IO Int
%call (diag d)
%code int nr = clang_getDiagnosticNumRanges(d);
%result (int nr)

-- CXSourceRange clang_getDiagnosticRange(CXDiagnostic Diagnostic,
--                                                       unsigned Range);
%fun clang_getDiagnosticRange :: Diagnostic s' -> Int -> IO (SourceRange s)
%call (diag d) (int i)
%code CXSourceRange r = clang_getDiagnosticRange(d, i);
%result (sourceRange {r.ptr_data[0]} {r.ptr_data[1]} {r.begin_int_data} {r.end_int_data})

-- unsigned clang_getDiagnosticNumFixIts(CXDiagnostic Diagnostic);
%fun clang_getDiagnosticNumFixIts :: Diagnostic s -> IO Int
%call (diag d)
%code int nf = clang_getDiagnosticNumFixIts(d);
%result (int nf)

-- CXString clang_getDiagnosticFixIt(CXDiagnostic Diagnostic,
--                                                  unsigned FixIt,
--                                                CXSourceRange *ReplacementRange);
%fun unsafe_getDiagnosticFixIt :: Diagnostic s' -> Int -> IO (SourceRange s, CXString ())
%call (diag d) (int i)
%code CXSourceRange a;
%     CXString out = clang_getDiagnosticFixIt(d, i, &a);
%     const void* outData = out.data;
%     unsigned outFlags = out.private_flags;
%result ((sourceRange {a.ptr_data[0]} {a.ptr_data[1]} {a.begin_int_data} {a.end_int_data}), (cxString (ptr outData) (word32 outFlags)))

getDiagnosticFixIt :: ClangBase m => Diagnostic s' -> Int
                   -> ClangT s m (SourceRange s, CXString s)
getDiagnosticFixIt d i = do
  (r, s) <- liftIO $ unsafe_getDiagnosticFixIt d i
  (r,) <$> registerCXString (return s)

-- CXString
-- clang_getTranslationUnitSpelling(CXTranslationUnit CTUnit);
%fun unsafe_getTranslationUnitSpelling :: TranslationUnit s -> IO (CXString ())
%call (translationUnit t)
%code CXString out = clang_getTranslationUnitSpelling(t);
%     const void* outData = out.data;
%     unsigned outFlags = out.private_flags;
%result (cxString (ptr outData) (word32 outFlags))

getTranslationUnitSpelling :: ClangBase m => TranslationUnit s' -> ClangT s m (CXString s)
getTranslationUnitSpelling = registerCXString . unsafe_getTranslationUnitSpelling

-- CXTranslationUnit clang_createTranslationUnitFromSourceFile(
--                                          CXIndex CIdx,
--                                          const char *source_filename,
--                                          int num_clang_command_line_args,
--                                    const char * const *clang_command_line_args,
--                                          unsigned num_unsaved_files,
--                                          struct CXUnsavedFile *unsaved_files);
%fun unsafe_createTranslationUnitFromSourceFile :: Index s -> String -> Int -> Ptr CString -> Int -> Ptr CUnsavedFile -> IO (TranslationUnit ())
%call (index i) (string s) (int nas) (ptr as) (int nufs) (ptr ufs)
%code r = clang_createTranslationUnitFromSourceFile(i,s,nas,as,nufs,ufs);
%result (translationUnit r)

createTranslationUnitFromSourceFile :: ClangBase m => Index s' -> String -> [String]
                                    -> DV.Vector UnsavedFile -> ClangT s m (TranslationUnit s)
createTranslationUnitFromSourceFile idx sf as ufs =
  registerTranslationUnit $
    withStringList as $ \asPtr asLen ->
      withUnsavedFiles ufs $ \ufsPtr ufsLen ->
        unsafe_createTranslationUnitFromSourceFile idx sf asLen asPtr ufsLen ufsPtr

-- CXTranslationUnit clang_createTranslationUnit(CXIndex,
--                                              const char *ast_filename);
%fun unsafe_createTranslationUnit :: Index s -> String -> IO (TranslationUnit ())
%call (index i) (string s)
%code CXTranslationUnit r = clang_createTranslationUnit(i, s);
%result (translationUnit r)

createTranslationUnit :: ClangBase m => Index s' -> String -> ClangT s m (TranslationUnit s)
createTranslationUnit = (registerTranslationUnit .) . unsafe_createTranslationUnit

-- enum CXTranslationUnit_Flags {
--   CXTranslationUnit_None = 0x0,
--   CXTranslationUnit_DetailedPreprocessingRecord = 0x01,
--   CXTranslationUnit_Incomplete = 0x02,
--   CXTranslationUnit_PrecompiledPreamble = 0x04,
--   CXTranslationUnit_CacheCompletionResults = 0x08,
--   CXTranslationUnit_ForSerialization = 0x10,
--   CXTranslationUnit_CXXChainedPCH = 0x20,
--   CXTranslationUnit_SkipFunctionBodies = 0x40,
--   CXTranslationUnit_IncludeBriefCommentsInCodeCompletion = 0x80
-- };

%enum TranslationUnitFlags (Bounded, Enum, Eq, Ord, Read, Show) Int [CXTranslationUnit_None, CXTranslationUnit_DetailedPreprocessingRecord, CXTranslationUnit_Incomplete, CXTranslationUnit_PrecompiledPreamble, CXTranslationUnit_CacheCompletionResults, CXTranslationUnit_ForSerialization, CXTranslationUnit_CXXChainedPCH, CXTranslationUnit_SkipFunctionBodies, CXTranslationUnit_IncludeBriefCommentsInCodeCompletion]

instance BitFlags TranslationUnitFlags where
  toBit TranslationUnit_None                                 = 0x0
  toBit TranslationUnit_DetailedPreprocessingRecord          = 0x01
  toBit TranslationUnit_Incomplete                           = 0x02
  toBit TranslationUnit_PrecompiledPreamble                  = 0x04
  toBit TranslationUnit_CacheCompletionResults               = 0x08
  toBit TranslationUnit_ForSerialization                     = 0x10
  toBit TranslationUnit_CXXChainedPCH                        = 0x20
  toBit TranslationUnit_SkipFunctionBodies                   = 0x40
  toBit TranslationUnit_IncludeBriefCommentsInCodeCompletion = 0x80

-- unsigned clang_defaultEditingTranslationUnitOptions(void);
%fun clang_defaultEditingTranslationUnitOptions :: IO Int

-- CXTranslationUnit clang_parseTranslationUnit(CXIndex CIdx,
--                                                     const char *source_filename,
--                                          const char * const *command_line_args,
--                                                       int num_command_line_args,
--                                             struct CXUnsavedFile *unsaved_files,
--                                                      unsigned num_unsaved_files,
--                                                             unsigned options);
%fun unsafe_parseTranslationUnit :: Index s -> Maybe String -> Ptr CString -> Int -> Ptr CUnsavedFile -> Int -> Int -> IO (Maybe (TranslationUnit ()))
%call (index i) (maybeT {nullPtr} (string s)) (ptr as) (int nas) (ptr ufs) (int nufs) (int i2)
%code r = clang_parseTranslationUnit(i,s,as,nas,ufs,nufs,i2);
%result (maybeT {nullPtr} (translationUnit r))

parseTranslationUnit :: ClangBase m => Index s' -> Maybe String -> [String]
                     -> DV.Vector UnsavedFile -> Int -> ClangT s m (Maybe (TranslationUnit s))
parseTranslationUnit idx sf as ufs opts = do
    mayTU <- liftIO $
      withStringList as $ \asPtr asLen ->
        withUnsavedFiles ufs $ \ufsPtr ufsLen ->
          unsafe_parseTranslationUnit idx sf asPtr asLen ufsPtr ufsLen opts
    case mayTU of
      Just tu -> Just <$> registerTranslationUnit (return tu)
      Nothing -> return Nothing

withStringList :: [String] -> (Ptr CString -> Int -> IO a) -> IO a
withStringList [] f = f nullPtr 0
withStringList ss f = do
    let len = length ss
    allocaArray len $ \arr -> go f arr len arr ss
  where
    go :: (Ptr CString -> Int -> IO a) -> Ptr CString -> Int -> Ptr CString -> [String] -> IO a
    go f arr len _ [] = f arr len
    go f arr len ptr (s : ss) = withCString s $ \cs -> do
      poke ptr cs
      go f arr len (advancePtr ptr 1) ss

-- void clang_setClangResourcesPath(CXIndex CIdx, const char* path);
%fun clang_setClangResourcesPath :: Index s -> String -> IO ()
%call (index i) (string s)
%code clang_setClangResourcesPath(i, s);

-- enum CXSaveTranslationUnit_Flags {
--   CXSaveTranslationUnit_None = 0x0
-- };
%enum SaveTranslationUnitFlags (Bounded, Enum, Eq, Ord, Read, Show) Int [CXSaveTranslationUnit_None]

instance BitFlags SaveTranslationUnitFlags where
  toBit SaveTranslationUnit_None = 0x0

-- unsigned clang_defaultSaveOptions(CXTranslationUnit TU);
%fun clang_defaultSaveOptions :: TranslationUnit s -> IO Int
%call (translationUnit t)
%code r = clang_defaultSaveOptions(t);
%result (int r)

-- int clang_saveTranslationUnit(CXTranslationUnit TU,
--                                              const char *FileName,
--                                              unsigned options);
%fun clang_saveTranslationUnit :: TranslationUnit s -> String -> Int -> IO Bool
%call (translationUnit t) (string s) (int i)
%code unsigned r = clang_saveTranslationUnit(t, s, i);
%result (bool {r!=0?0:1})

-- enum CXReparse_Flags {
--   CXReparse_None = 0x0
-- };
%enum ReparseFlags (Bounded, Enum, Eq, Ord, Read, Show) Int [CXReparse_None]

instance BitFlags ReparseFlags where
  toBit Reparse_None = 0x0

-- unsigned clang_defaultReparseOptions(CXTranslationUnit TU);
%fun clang_defaultReparseOptions :: TranslationUnit s -> IO Int
%call (translationUnit t)
%code r = clang_defaultReparseOptions(t);
%result (int r)

-- int clang_reparseTranslationUnit(CXTranslationUnit TU,
--                                                 unsigned num_unsaved_files,
--                                           struct CXUnsavedFile *unsaved_files,
--                                                 unsigned options);
%fun unsafe_reparseTranslationUnit :: TranslationUnit s -> Ptr CUnsavedFile -> Int -> Int -> IO Bool
%call (translationUnit t) (ptr ufs) (int nufs) (int i)
%code r = clang_reparseTranslationUnit(t, nufs, ufs, i);
%result (bool r)

reparseTranslationUnit :: ClangBase m => TranslationUnit s' -> DV.Vector UnsavedFile -> Int
                       -> ClangT s m Bool
reparseTranslationUnit tu ufs opts = liftIO $
  withUnsavedFiles ufs $ \ufsPtr ufsLen ->
    unsafe_reparseTranslationUnit tu ufsPtr ufsLen opts


-- enum CXCursorKind {
--   /* Declarations */
--   /**
--    * \brief A declaration whose specific kind is not exposed via this
--    * interface.
--    *
--    * Unexposed declarations have the same operations as any other kind
--    * of declaration; one can extract their location information,
--    * spelling, find their definitions, etc. However, the specific kind
--    * of the declaration is not reported.
--    */
--   CXCursor_UnexposedDecl                 = 1,
--   /** \brief A C or C++ struct. */
--   CXCursor_StructDecl                    = 2,
--   /** \brief A C or C++ union. */
--   CXCursor_UnionDecl                     = 3,
--   /** \brief A C++ class. */
--   CXCursor_ClassDecl                     = 4,
--   /** \brief An enumeration. */
--   CXCursor_EnumDecl                      = 5,
--   /**
--    * \brief A field (in C) or non-static data member (in C++) in a
--    * struct, union, or C++ class.
--    */
--   CXCursor_FieldDecl                     = 6,
--   /** \brief An enumerator constant. */
--   CXCursor_EnumConstantDecl              = 7,
--   /** \brief A function. */
--   CXCursor_FunctionDecl                  = 8,
--   /** \brief A variable. */
--   CXCursor_VarDecl                       = 9,
--   /** \brief A function or method parameter. */
--   CXCursor_ParmDecl                      = 10,
--   /** \brief An Objective-C @interface. */
--   CXCursor_ObjCInterfaceDecl             = 11,
--   /** \brief An Objective-C @interface for a category. */
--   CXCursor_ObjCCategoryDecl              = 12,
--   /** \brief An Objective-C @protocol declaration. */
--   CXCursor_ObjCProtocolDecl              = 13,
--   /** \brief An Objective-C @property declaration. */
--   CXCursor_ObjCPropertyDecl              = 14,
--   /** \brief An Objective-C instance variable. */
--   CXCursor_ObjCIvarDecl                  = 15,
--   /** \brief An Objective-C instance method. */
--   CXCursor_ObjCInstanceMethodDecl        = 16,
--   /** \brief An Objective-C class method. */
--   CXCursor_ObjCClassMethodDecl           = 17,
--   /** \brief An Objective-C @implementation. */
--   CXCursor_ObjCImplementationDecl        = 18,
--   /** \brief An Objective-C @implementation for a category. */
--   CXCursor_ObjCCategoryImplDecl          = 19,
--   /** \brief A typedef */
--   CXCursor_TypedefDecl                   = 20,
--   /** \brief A C++ class method. */
--   CXCursor_CXXMethod                     = 21,
--   /** \brief A C++ namespace. */
--   CXCursor_Namespace                     = 22,
--   /** \brief A linkage specification, e.g. 'extern "C"'. */
--   CXCursor_LinkageSpec                   = 23,
--   /** \brief A C++ constructor. */
--   CXCursor_Constructor                   = 24,
--   /** \brief A C++ destructor. */
--   CXCursor_Destructor                    = 25,
--   /** \brief A C++ conversion function. */
--   CXCursor_ConversionFunction            = 26,
--   /** \brief A C++ template type parameter. */
--   CXCursor_TemplateTypeParameter         = 27,
--   /** \brief A C++ non-type template parameter. */
--   CXCursor_NonTypeTemplateParameter      = 28,
--   /** \brief A C++ template template parameter. */
--   CXCursor_TemplateTemplateParameter     = 29,
--   /** \brief A C++ function template. */
--   CXCursor_FunctionTemplate              = 30,
--   /** \brief A C++ class template. */
--   CXCursor_ClassTemplate                 = 31,
--   /** \brief A C++ class template partial specialization. */
--   CXCursor_ClassTemplatePartialSpecialization = 32,
--   /** \brief A C++ namespace alias declaration. */
--   CXCursor_NamespaceAlias                = 33,
--   /** \brief A C++ using directive. */
--   CXCursor_UsingDirective                = 34,
--   /** \brief A C++ using declaration. */
--   CXCursor_UsingDeclaration              = 35,
--   /** \brief A C++ alias declaration */
--   CXCursor_TypeAliasDecl                 = 36,
--   /** \brief An Objective-C @synthesize definition. */
--   CXCursor_ObjCSynthesizeDecl            = 37,
--   /** \brief An Objective-C @dynamic definition. */
--   CXCursor_ObjCDynamicDecl               = 38,
--   /** \brief An access specifier. */
--   CXCursor_CXXAccessSpecifier            = 39,
-- 
--   CXCursor_FirstDecl                     = CXCursor_UnexposedDecl,
--   CXCursor_LastDecl                      = CXCursor_CXXAccessSpecifier,
-- 
--   /* References */
--   CXCursor_FirstRef                      = 40, /* Decl references */
--   CXCursor_ObjCSuperClassRef             = 40,
--   CXCursor_ObjCProtocolRef               = 41,
--   CXCursor_ObjCClassRef                  = 42,
--   /**
--    * \brief A reference to a type declaration.
--    *
--    * A type reference occurs anywhere where a type is named but not
--    * declared. For example, given:
--    *
--    * \code
--    * typedef unsigned size_type;
--    * size_type size;
--    * \endcode
--    *
--    * The typedef is a declaration of size_type (CXCursor_TypedefDecl),
--    * while the type of the variable "size" is referenced. The cursor
--    * referenced by the type of size is the typedef for size_type.
--    */
--   CXCursor_TypeRef                       = 43,
--   CXCursor_CXXBaseSpecifier              = 44,
--   /** 
--    * \brief A reference to a class template, function template, template
--    * template parameter, or class template partial specialization.
--    */
--   CXCursor_TemplateRef                   = 45,
--   /**
--    * \brief A reference to a namespace or namespace alias.
--    */
--   CXCursor_NamespaceRef                  = 46,
--   /**
--    * \brief A reference to a member of a struct, union, or class that occurs in 
--    * some non-expression context, e.g., a designated initializer.
--    */
--   CXCursor_MemberRef                     = 47,
--   /**
--    * \brief A reference to a labeled statement.
--    *
--    * This cursor kind is used to describe the jump to "start_over" in the 
--    * goto statement in the following example:
--    *
--    * \code
--    *   start_over:
--    *     ++counter;
--    *
--    *     goto start_over;
--    * \endcode
--    *
--    * A label reference cursor refers to a label statement.
--    */
--   CXCursor_LabelRef                      = 48,
--   
--   /**
--    * \brief A reference to a set of overloaded functions or function templates
--    * that has not yet been resolved to a specific function or function template.
--    *
--    * An overloaded declaration reference cursor occurs in C++ templates where
--    * a dependent name refers to a function. For example:
--    *
--    * \code
--    * template<typename T> void swap(T&, T&);
--    *
--    * struct X { ... };
--    * void swap(X&, X&);
--    *
--    * template<typename T>
--    * void reverse(T* first, T* last) {
--    *   while (first < last - 1) {
--    *     swap(*first, *--last);
--    *     ++first;
--    *   }
--    * }
--    *
--    * struct Y { };
--    * void swap(Y&, Y&);
--    * \endcode
--    *
--    * Here, the identifier "swap" is associated with an overloaded declaration
--    * reference. In the template definition, "swap" refers to either of the two
--    * "swap" functions declared above, so both results will be available. At
--    * instantiation time, "swap" may also refer to other functions found via
--    * argument-dependent lookup (e.g., the "swap" function at the end of the
--    * example).
--    *
--    * The functions \c clang_getNumOverloadedDecls() and 
--    * \c clang_getOverloadedDecl() can be used to retrieve the definitions
--    * referenced by this cursor.
--    */
--   CXCursor_OverloadedDeclRef             = 49,
--   
--   /*
--    * \brief A reference to a variable that occurs in some non-expression 
--    * context, e.g., a C++ lambda capture list.
--    */
--   CXCursor_VariableRef                   = 50,
--  
--   CXCursor_LastRef                       = CXCursor_VariableRef,
-- 
--   /* Error conditions */
--   CXCursor_FirstInvalid                  = 70,
--   CXCursor_InvalidFile                   = 70,
--   CXCursor_NoDeclFound                   = 71,
--   CXCursor_NotImplemented                = 72,
--   CXCursor_InvalidCode                   = 73,
--   CXCursor_LastInvalid                   = CXCursor_InvalidCode,
-- 
--   /* Expressions */
--   CXCursor_FirstExpr                     = 100,
-- 
--   /**
--    * \brief An expression whose specific kind is not exposed via this
--    * interface.
--    *
--    * Unexposed expressions have the same operations as any other kind
--    * of expression; one can extract their location information,
--    * spelling, children, etc. However, the specific kind of the
--    * expression is not reported.
--    */
--   CXCursor_UnexposedExpr                 = 100,
-- 
--   /**
--    * \brief An expression that refers to some value declaration, such
--    * as a function, varible, or enumerator.
--    */
--   CXCursor_DeclRefExpr                   = 101,
-- 
--   /**
--    * \brief An expression that refers to a member of a struct, union,
--    * class, Objective-C class, etc.
--    */
--   CXCursor_MemberRefExpr                 = 102,
-- 
--   /** \brief An expression that calls a function. */
--   CXCursor_CallExpr                      = 103,
-- 
--   /** \brief An expression that sends a message to an Objective-C
--    object or class. */
--   CXCursor_ObjCMessageExpr               = 104,
-- 
--   /** \brief An expression that represents a block literal. */
--   CXCursor_BlockExpr                     = 105,
-- 
--   /** \brief An integer literal.
--    */
--   CXCursor_IntegerLiteral                = 106,
-- 
--   /** \brief A floating point number literal.
--    */
--   CXCursor_FloatingLiteral               = 107,
-- 
--   /** \brief An imaginary number literal.
--    */
--   CXCursor_ImaginaryLiteral              = 108,
-- 
--   /** \brief A string literal.
--    */
--   CXCursor_StringLiteral                 = 109,
-- 
--   /** \brief A character literal.
--    */
--   CXCursor_CharacterLiteral              = 110,
-- 
--   /** \brief A parenthesized expression, e.g. "(1)".
--    *
--    * This AST node is only formed if full location information is requested.
--    */
--   CXCursor_ParenExpr                     = 111,
-- 
--   /** \brief This represents the unary-expression's (except sizeof and
--    * alignof).
--    */
--   CXCursor_UnaryOperator                 = 112,
-- 
--   /** \brief [C99 6.5.2.1] Array Subscripting.
--    */
--   CXCursor_ArraySubscriptExpr            = 113,
-- 
--   /** \brief A builtin binary operation expression such as "x + y" or
--    * "x <= y".
--    */
--   CXCursor_BinaryOperator                = 114,
-- 
--   /** \brief Compound assignment such as "+=".
--    */
--   CXCursor_CompoundAssignOperator        = 115,
-- 
--   /** \brief The ?: ternary operator.
--    */
--   CXCursor_ConditionalOperator           = 116,
-- 
--   /** \brief An explicit cast in C (C99 6.5.4) or a C-style cast in C++
--    * (C++ [expr.cast]), which uses the syntax (Type)expr.
--    *
--    * For example: (int)f.
--    */
--   CXCursor_CStyleCastExpr                = 117,
-- 
--   /** \brief [C99 6.5.2.5]
--    */
--   CXCursor_CompoundLiteralExpr           = 118,
-- 
--   /** \brief Describes an C or C++ initializer list.
--    */
--   CXCursor_InitListExpr                  = 119,
-- 
--   /** \brief The GNU address of label extension, representing &&label.
--    */
--   CXCursor_AddrLabelExpr                 = 120,
-- 
--   /** \brief This is the GNU Statement Expression extension: ({int X=4; X;})
--    */
--   CXCursor_StmtExpr                      = 121,
-- 
--   /** \brief Represents a C1X generic selection.
--    */
--   CXCursor_GenericSelectionExpr          = 122,
-- 
--   /** \brief Implements the GNU __null extension, which is a name for a null
--    * pointer constant that has integral type (e.g., int or long) and is the same
--    * size and alignment as a pointer.
--    *
--    * The __null extension is typically only used by system headers, which define
--    * NULL as __null in C++ rather than using 0 (which is an integer that may not
--    * match the size of a pointer).
--    */
--   CXCursor_GNUNullExpr                   = 123,
-- 
--   /** \brief C++'s static_cast<> expression.
--    */
--   CXCursor_CXXStaticCastExpr             = 124,
-- 
--   /** \brief C++'s dynamic_cast<> expression.
--    */
--   CXCursor_CXXDynamicCastExpr            = 125,
-- 
--   /** \brief C++'s reinterpret_cast<> expression.
--    */
--   CXCursor_CXXReinterpretCastExpr        = 126,
-- 
--   /** \brief C++'s const_cast<> expression.
--    */
--   CXCursor_CXXConstCastExpr              = 127,
-- 
--   /** \brief Represents an explicit C++ type conversion that uses "functional"
--    * notion (C++ [expr.type.conv]).
--    *
--    * Example:
--    * \code
--    *   x = int(0.5);
--    * \endcode
--    */
--   CXCursor_CXXFunctionalCastExpr         = 128,
-- 
--   /** \brief A C++ typeid expression (C++ [expr.typeid]).
--    */
--   CXCursor_CXXTypeidExpr                 = 129,
-- 
--   /** \brief [C++ 2.13.5] C++ Boolean Literal.
--    */
--   CXCursor_CXXBoolLiteralExpr            = 130,
-- 
--   /** \brief [C++0x 2.14.7] C++ Pointer Literal.
--    */
--   CXCursor_CXXNullPtrLiteralExpr         = 131,
-- 
--   /** \brief Represents the "this" expression in C++
--    */
--   CXCursor_CXXThisExpr                   = 132,
-- 
--   /** \brief [C++ 15] C++ Throw Expression.
--    *
--    * This handles 'throw' and 'throw' assignment-expression. When
--    * assignment-expression isn't present, Op will be null.
--    */
--   CXCursor_CXXThrowExpr                  = 133,
-- 
--   /** \brief A new expression for memory allocation and constructor calls, e.g:
--    * "new CXXNewExpr(foo)".
--    */
--   CXCursor_CXXNewExpr                    = 134,
-- 
--   /** \brief A delete expression for memory deallocation and destructor calls,
--    * e.g. "delete[] pArray".
--    */
--   CXCursor_CXXDeleteExpr                 = 135,
-- 
--   /** \brief A unary expression.
--    */
--   CXCursor_UnaryExpr                     = 136,
-- 
--   /** \brief ObjCStringLiteral, used for Objective-C string literals i.e. "foo".
--    */
--   CXCursor_ObjCStringLiteral             = 137,
-- 
--   /** \brief ObjCEncodeExpr, used for in Objective-C.
--    */
--   CXCursor_ObjCEncodeExpr                = 138,
-- 
--   /** \brief ObjCSelectorExpr used for in Objective-C.
--    */
--   CXCursor_ObjCSelectorExpr              = 139,
-- 
--   /** \brief Objective-C's protocol expression.
--    */
--   CXCursor_ObjCProtocolExpr              = 140,
-- 
--   /** \brief An Objective-C "bridged" cast expression, which casts between
--    * Objective-C pointers and C pointers, transferring ownership in the process.
--    *
--    * \code
--    *   NSString *str = (__bridge_transfer NSString *)CFCreateString();
--    * \endcode
--    */
--   CXCursor_ObjCBridgedCastExpr           = 141,
-- 
--   /** \brief Represents a C++0x pack expansion that produces a sequence of
--    * expressions.
--    *
--    * A pack expansion expression contains a pattern (which itself is an
--    * expression) followed by an ellipsis. For example:
--    *
--    * \code
--    * template<typename F, typename ...Types>
--    * void forward(F f, Types &&...args) {
--    *  f(static_cast<Types&&>(args)...);
--    * }
--    * \endcode
--    */
--   CXCursor_PackExpansionExpr             = 142,
-- 
--   /** \brief Represents an expression that computes the length of a parameter
--    * pack.
--    *
--    * \code
--    * template<typename ...Types>
--    * struct count {
--    *   static const unsigned value = sizeof...(Types);
--    * };
--    * \endcode
--    */
--   CXCursor_SizeOfPackExpr                = 143,
--
--   /* \brief Represents a C++ lambda expression that produces a local function
--    * object.
--    *
--    * \code
--    * void abssort(float *x, unsigned N) {
--    *   std::sort(x, x + N,
--    *             [](float a, float b) {
--    *               return std::abs(a) < std::abs(b);
--    *             });
--    * }
--    * \endcode
--    */
--   CXCursor_LambdaExpr                    = 144,
--   
--   /** \brief Objective-c Boolean Literal.
--    */
--   CXCursor_ObjCBoolLiteralExpr           = 145,
-- 
--   /** \brief Represents the "self" expression in a ObjC method.
--    */
--   CXCursor_ObjCSelfExpr                  = 146,
-- 
--   CXCursor_LastExpr                      = CXCursor_ObjCSelfExpr,
-- 
--   /* Statements */
--   CXCursor_FirstStmt                     = 200,
--   /**
--    * \brief A statement whose specific kind is not exposed via this
--    * interface.
--    *
--    * Unexposed statements have the same operations as any other kind of
--    * statement; one can extract their location information, spelling,
--    * children, etc. However, the specific kind of the statement is not
--    * reported.
--    */
--   CXCursor_UnexposedStmt                 = 200,
--   
--   /** \brief A labelled statement in a function. 
--    *
--    * This cursor kind is used to describe the "start_over:" label statement in 
--    * the following example:
--    *
--    * \code
--    *   start_over:
--    *     ++counter;
--    * \endcode
--    *
--    */
--   CXCursor_LabelStmt                     = 201,
-- 
--   /** \brief A group of statements like { stmt stmt }.
--    *
--    * This cursor kind is used to describe compound statements, e.g. function
--    * bodies.
--    */
--   CXCursor_CompoundStmt                  = 202,
-- 
--   /** \brief A case statment.
--    */
--   CXCursor_CaseStmt                      = 203,
-- 
--   /** \brief A default statement.
--    */
--   CXCursor_DefaultStmt                   = 204,
-- 
--   /** \brief An if statement
--    */
--   CXCursor_IfStmt                        = 205,
-- 
--   /** \brief A switch statement.
--    */
--   CXCursor_SwitchStmt                    = 206,
-- 
--   /** \brief A while statement.
--    */
--   CXCursor_WhileStmt                     = 207,
-- 
--   /** \brief A do statement.
--    */
--   CXCursor_DoStmt                        = 208,
-- 
--   /** \brief A for statement.
--    */
--   CXCursor_ForStmt                       = 209,
-- 
--   /** \brief A goto statement.
--    */
--   CXCursor_GotoStmt                      = 210,
-- 
--   /** \brief An indirect goto statement.
--    */
--   CXCursor_IndirectGotoStmt              = 211,
-- 
--   /** \brief A continue statement.
--    */
--   CXCursor_ContinueStmt                  = 212,
-- 
--   /** \brief A break statement.
--    */
--   CXCursor_BreakStmt                     = 213,
-- 
--   /** \brief A return statement.
--    */
--   CXCursor_ReturnStmt                    = 214,
-- 
--   /** \brief A GNU inline assembly statement extension.
--    */
--   CXCursor_GCCAsmStmt                    = 215,
--   CXCursor_AsmStmt                       = CXCursor_GCCAsmStmt,
-- 
--   /** \brief Objective-C's overall @try-@catc-@finall statement.
--    */
--   CXCursor_ObjCAtTryStmt                 = 216,
-- 
--   /** \brief Objective-C's @catch statement.
--    */
--   CXCursor_ObjCAtCatchStmt               = 217,
-- 
--   /** \brief Objective-C's @finally statement.
--    */
--   CXCursor_ObjCAtFinallyStmt             = 218,
-- 
--   /** \brief Objective-C's @throw statement.
--    */
--   CXCursor_ObjCAtThrowStmt               = 219,
-- 
--   /** \brief Objective-C's @synchronized statement.
--    */
--   CXCursor_ObjCAtSynchronizedStmt        = 220,
-- 
--   /** \brief Objective-C's autorelease pool statement.
--    */
--   CXCursor_ObjCAutoreleasePoolStmt       = 221,
-- 
--   /** \brief Objective-C's collection statement.
--    */
--   CXCursor_ObjCForCollectionStmt         = 222,
-- 
--   /** \brief C++'s catch statement.
--    */
--   CXCursor_CXXCatchStmt                  = 223,
-- 
--   /** \brief C++'s try statement.
--    */
--   CXCursor_CXXTryStmt                    = 224,
-- 
--   /** \brief C++'s for (* : *) statement.
--    */
--   CXCursor_CXXForRangeStmt               = 225,
-- 
--   /** \brief Windows Structured Exception Handling's try statement.
--    */
--   CXCursor_SEHTryStmt                    = 226,
-- 
--   /** \brief Windows Structured Exception Handling's except statement.
--    */
--   CXCursor_SEHExceptStmt                 = 227,
-- 
--   /** \brief Windows Structured Exception Handling's finally statement.
--    */
--   CXCursor_SEHFinallyStmt                = 228,
-- 
--   /** \brief A MS inline assembly statement extension.
--    */
--   CXCursor_MSAsmStmt                     = 229,
--
--   /** \brief The null satement ";": C99 6.8.3p3.
--    *
--    * This cursor kind is used to describe the null statement.
--    */
--   CXCursor_NullStmt                      = 230,
-- 
--   /** \brief Adaptor class for mixing declarations with statements and
--    * expressions.
--    */
--   CXCursor_DeclStmt                      = 231,
-- 
--   /** \brief OpenMP parallel directive.
--    */
--   CXCursor_OMPParallelDirective          = 232,
-- 
--   CXCursor_LastStmt                      = CXCursor_OMPParallelDirective,
-- 
--   /**
--    * \brief Cursor that represents the translation unit itself.
--    *
--    * The translation unit cursor exists primarily to act as the root
--    * cursor for traversing the contents of a translation unit.
--    */
--   CXCursor_TranslationUnit               = 300,
-- 
--   /* Attributes */
--   CXCursor_FirstAttr                     = 400,
--   /**
--    * \brief An attribute whose specific kind is not exposed via this
--    * interface.
--    */
--   CXCursor_UnexposedAttr                 = 400,
-- 
--   CXCursor_IBActionAttr                  = 401,
--   CXCursor_IBOutletAttr                  = 402,
--   CXCursor_IBOutletCollectionAttr        = 403,
--   CXCursor_CXXFinalAttr                  = 404,
--   CXCursor_CXXOverrideAttr               = 405,
--   CXCursor_AnnotateAttr                  = 406,
--   CXCursor_AsmLabelAttr                  = 407,
--   CXCursor_PackedAttr                    = 408,
--   CXCursor_LastAttr                      = CXCursor_PackedAttr,
--      
--   /* Preprocessing */
--   CXCursor_PreprocessingDirective        = 500,
--   CXCursor_MacroDefinition               = 501,
--   CXCursor_MacroExpansion                = 502,
--   CXCursor_MacroInstantiation            = CXCursor_MacroExpansion,
--   CXCursor_InclusionDirective            = 503,
--   CXCursor_FirstPreprocessing            = CXCursor_PreprocessingDirective,
--   CXCursor_LastPreprocessing             = CXCursor_InclusionDirective
--
--   /* Extra Declarations */
--   /**
--    * \brief A module import declaration.
--    */
--   CXCursor_ModuleImportDecl              = 600,
--   CXCursor_FirstExtraDecl                = CXCursor_ModuleImportDecl,
--   CXCursor_LastExtraDecl                 = CXCursor_ModuleImportDecl
-- };
%enum CursorKind (Bounded, Enum, Eq, Ord, Read, Show) Int [CXCursor_UnexposedDecl,CXCursor_StructDecl,CXCursor_UnionDecl,CXCursor_ClassDecl,CXCursor_EnumDecl,CXCursor_FieldDecl,CXCursor_EnumConstantDecl,CXCursor_FunctionDecl,CXCursor_VarDecl,CXCursor_ParmDecl,CXCursor_ObjCInterfaceDecl,CXCursor_ObjCCategoryDecl,CXCursor_ObjCProtocolDecl,CXCursor_ObjCPropertyDecl,CXCursor_ObjCIvarDecl,CXCursor_ObjCInstanceMethodDecl,CXCursor_ObjCClassMethodDecl,CXCursor_ObjCImplementationDecl,CXCursor_ObjCCategoryImplDecl,CXCursor_TypedefDecl,CXCursor_CXXMethod,CXCursor_Namespace,CXCursor_LinkageSpec,CXCursor_Constructor,CXCursor_Destructor,CXCursor_ConversionFunction,CXCursor_TemplateTypeParameter,CXCursor_NonTypeTemplateParameter,CXCursor_TemplateTemplateParameter,CXCursor_FunctionTemplate,CXCursor_ClassTemplate,CXCursor_ClassTemplatePartialSpecialization,CXCursor_NamespaceAlias,CXCursor_UsingDirective,CXCursor_UsingDeclaration,CXCursor_TypeAliasDecl,CXCursor_ObjCSynthesizeDecl,CXCursor_ObjCDynamicDecl,CXCursor_CXXAccessSpecifier,CXCursor_ObjCSuperClassRef,CXCursor_ObjCProtocolRef,CXCursor_ObjCClassRef,CXCursor_TypeRef,CXCursor_CXXBaseSpecifier,CXCursor_TemplateRef,CXCursor_NamespaceRef,CXCursor_MemberRef,CXCursor_LabelRef,CXCursor_OverloadedDeclRef,CXCursor_VariableRef,CXCursor_InvalidFile,CXCursor_NoDeclFound,CXCursor_NotImplemented,CXCursor_InvalidCode,CXCursor_UnexposedExpr,CXCursor_DeclRefExpr,CXCursor_MemberRefExpr,CXCursor_CallExpr,CXCursor_ObjCMessageExpr,CXCursor_BlockExpr,CXCursor_IntegerLiteral,CXCursor_FloatingLiteral,CXCursor_ImaginaryLiteral,CXCursor_StringLiteral,CXCursor_CharacterLiteral,CXCursor_ParenExpr,CXCursor_UnaryOperator,CXCursor_ArraySubscriptExpr,CXCursor_BinaryOperator,CXCursor_CompoundAssignOperator,CXCursor_ConditionalOperator,CXCursor_CStyleCastExpr,CXCursor_CompoundLiteralExpr,CXCursor_InitListExpr,CXCursor_AddrLabelExpr,CXCursor_StmtExpr,CXCursor_GenericSelectionExpr,CXCursor_GNUNullExpr,CXCursor_CXXStaticCastExpr,CXCursor_CXXDynamicCastExpr,CXCursor_CXXReinterpretCastExpr,CXCursor_CXXConstCastExpr,CXCursor_CXXFunctionalCastExpr,CXCursor_CXXTypeidExpr,CXCursor_CXXBoolLiteralExpr,CXCursor_CXXNullPtrLiteralExpr,CXCursor_CXXThisExpr,CXCursor_CXXThrowExpr,CXCursor_CXXNewExpr,CXCursor_CXXDeleteExpr,CXCursor_UnaryExpr,CXCursor_ObjCStringLiteral,CXCursor_ObjCEncodeExpr,CXCursor_ObjCSelectorExpr,CXCursor_ObjCProtocolExpr,CXCursor_ObjCBridgedCastExpr,CXCursor_PackExpansionExpr,CXCursor_SizeOfPackExpr,CXCursor_LambdaExpr,CXCursor_ObjCBoolLiteralExpr,CXCursor_ObjCSelfExpr,CXCursor_UnexposedStmt,CXCursor_LabelStmt,CXCursor_CompoundStmt,CXCursor_CaseStmt,CXCursor_DefaultStmt,CXCursor_IfStmt,CXCursor_SwitchStmt,CXCursor_WhileStmt,CXCursor_DoStmt,CXCursor_ForStmt,CXCursor_GotoStmt,CXCursor_IndirectGotoStmt,CXCursor_ContinueStmt,CXCursor_BreakStmt,CXCursor_ReturnStmt,CXCursor_AsmStmt,CXCursor_ObjCAtTryStmt,CXCursor_ObjCAtCatchStmt,CXCursor_ObjCAtFinallyStmt,CXCursor_ObjCAtThrowStmt,CXCursor_ObjCAtSynchronizedStmt,CXCursor_ObjCAutoreleasePoolStmt,CXCursor_ObjCForCollectionStmt,CXCursor_CXXCatchStmt,CXCursor_CXXTryStmt,CXCursor_CXXForRangeStmt,CXCursor_SEHTryStmt,CXCursor_SEHExceptStmt,CXCursor_SEHFinallyStmt,CXCursor_MSAsmStmt,CXCursor_NullStmt,CXCursor_DeclStmt,CXCursor_OMPParallelDirective,CXCursor_TranslationUnit,CXCursor_UnexposedAttr,CXCursor_IBActionAttr,CXCursor_IBOutletAttr,CXCursor_IBOutletCollectionAttr,CXCursor_CXXFinalAttr,CXCursor_CXXOverrideAttr,CXCursor_AnnotateAttr,CXCursor_AsmLabelAttr,CXCursor_PackedAttr,CXCursor_PreprocessingDirective,CXCursor_MacroDefinition,CXCursor_MacroExpansion,CXCursor_InclusionDirective,CXCursor_ModuleImportDecl]

-- CursorKind ranges.
cursor_FirstDecl, cursor_LastDecl, cursor_FirstRef, cursor_LastRef         :: CursorKind
cursor_FirstInvalid, cursor_LastInvalid, cursor_FirstExpr, cursor_LastExpr :: CursorKind
cursor_FirstStmt, cursor_LastStmt, cursor_FirstAttr, cursor_LastAttr       :: CursorKind
cursor_FirstPreprocessing, cursor_LastPreprocessing                        :: CursorKind
cursor_FirstExtraDecl, cursor_LastExtraDecl                                :: CursorKind

cursor_FirstDecl          = Cursor_UnexposedDecl
cursor_LastDecl           = Cursor_CXXAccessSpecifier
cursor_FirstRef           = Cursor_ObjCSuperClassRef
cursor_LastRef            = Cursor_VariableRef
cursor_FirstInvalid       = Cursor_InvalidFile
cursor_LastInvalid        = Cursor_InvalidCode
cursor_FirstExpr          = Cursor_UnexposedExpr
cursor_LastExpr           = Cursor_ObjCSelfExpr
cursor_FirstStmt          = Cursor_UnexposedStmt
cursor_LastStmt           = Cursor_OMPParallelDirective
cursor_FirstAttr          = Cursor_UnexposedAttr
cursor_LastAttr           = Cursor_PackedAttr
cursor_FirstPreprocessing = Cursor_PreprocessingDirective
cursor_LastPreprocessing  = Cursor_InclusionDirective
cursor_FirstExtraDecl     = Cursor_ModuleImportDecl
cursor_LastExtraDecl      = Cursor_ModuleImportDecl

-- CursorKind aliases.
cursor_GCCAsmStmt, cursor_MacroInstantiation :: CursorKind
cursor_GCCAsmStmt         = Cursor_AsmStmt
cursor_MacroInstantiation = Cursor_MacroExpansion

-- typedef struct {
--   const void *ASTNode;
--   CXTranslationUnit TranslationUnit;
-- } CXComment;
data Comment s = Comment !(Ptr ()) !(Ptr ())
                 deriving (Eq)
%dis comment p1 p2 = Comment (ptr p1) (ptr p2)

instance Storable (Comment s) where
    sizeOf _ = sizeOfCXComment
    {-# INLINE sizeOf #-}

    alignment _ = alignOfCXComment
    {-# INLINE alignment #-}

    peek p = do
      p1 <- peekByteOff p offsetCXCommentASTNode
      p2 <- peekByteOff p offsetCXCommentTranslationUnit
      return $! Comment p1 p2
    {-# INLINE peek #-}

    poke p (Comment p1 p2) = do
      pokeByteOff p offsetCXCommentASTNode p1
      pokeByteOff p offsetCXCommentTranslationUnit p2
    {-# INLINE poke #-}

-- typedef struct {
--   enum CXCursorKind kind;
--   int xdata;
--   const void* data[3];
-- } CXCursor;
data Cursor s = Cursor !CursorKind !Int !(Ptr ()) !(Ptr ()) !(Ptr ())
%dis cursor k xdata p1 p2 p3 = Cursor (cursorKind k) (int xdata) (ptr p1) (ptr p2) (ptr p3)

instance Storable (Cursor s) where
    sizeOf _ = sizeOfCXCursor
    {-# INLINE sizeOf #-}

    alignment _ = alignOfCXCursor
    {-# INLINE alignment #-}

    peek p = do
      k <- (unmarshall_CursorKind . fromCInt) <$> peekByteOff p offsetCXCursorKind
      xdata <- fromCInt <$> peekByteOff p offsetCXCursorXData
      p1 <- peekByteOff p offsetCXCursorP1
      p2 <- peekByteOff p offsetCXCursorP2
      p3 <- peekByteOff p offsetCXCursorP3
      return $! Cursor k xdata p1 p2 p3
    {-# INLINE peek #-}

    poke p (Cursor k xdata p1 p2 p3) = do
      pokeByteOff p offsetCXCursorKind $ (toCInt . marshall_CursorKind) k
      pokeByteOff p offsetCXCursorXData $ toCInt xdata
      pokeByteOff p offsetCXCursorP1 p1
      pokeByteOff p offsetCXCursorP2 p2
      pokeByteOff p offsetCXCursorP3 p3
    {-# INLINE poke #-}

instance Eq (Cursor s) where
    (Cursor aK aXdata aP1 aP2 aP3) == (Cursor bK bXdata bP1 bP2 bP3) =
        (aK == bK) &&
        (aXdata == bXdata) &&
        (aP1 == bP1) &&
        (aP2' == bP2') &&
        (aP3 == bP3)
      where
        aP2' = if isDeclaration aK then intPtrToPtr 0 else aP2
        bP2' = if isDeclaration bK then intPtrToPtr 0 else bP2
    {-# INLINE (==) #-}

instance Hashable (Cursor s) where
    hash (Cursor k _ p1 p2 _) =
      let p = if isExpression k || isStatement k then p2 else p1
          kindHash = hash (marshall_CursorKind k)
          pAsInt = fromIntegral (ptrToIntPtr p) :: Int
          dataHash = hash pAsInt
      in kindHash `combine` dataHash
    {-# INLINE hash #-}

-- CXCursor clang_getNullCursor(void);
getNullCursor :: ClangBase m => ClangT s m (Cursor s)
getNullCursor =
  return $ Cursor Cursor_InvalidFile 0 (intPtrToPtr 0) (intPtrToPtr 0) (intPtrToPtr 0)
{-# INLINE getNullCursor #-}

-- CXCursor clang_getTranslationUnitCursor(CXTranslationUnit);
%fun clang_getTranslationUnitCursor :: Proxy s -> TranslationUnit s' -> IO (Cursor s)
%call (proxy) (translationUnit t)
%code CXCursor r = clang_getTranslationUnitCursor(t);
%result (cursor {r.kind}  {r.xdata} {r.data[0]} {r.data[1]} {r.data[2]})

-- int clang_Cursor_isNull(CXCursor);
cursor_isNull :: Cursor s -> Bool
cursor_isNull (Cursor k xdata p1 p2 p3)
  | k == Cursor_InvalidFile &&
    xdata == 0 &&
    p1 == intPtrToPtr 0 &&
    p2 == intPtrToPtr 0 &&
    p3 == intPtrToPtr 0
      = True
  | otherwise
      = False
{-# INLINE cursor_isNull #-}

-- unsigned clang_hashCursor(CXCursor);
%fun clang_hashCursor :: Cursor s -> IO Word32
%call (cursor k xdata p1 p2 p3)
%code CXCursor a = {k, xdata, {p1, p2, p3}};
%     unsigned r = clang_hashCursor(a);
%result (word32 r)
{-# INLINEABLE hashCursor #-}
 
getCursorKind :: Cursor s -> CursorKind
getCursorKind (Cursor k _ _ _ _) = k
{-# INLINE getCursorKind #-}

-- unsigned clang_isDeclaration(enum CursorKind);
isDeclaration :: CursorKind -> Bool
isDeclaration k =
  (k >= cursor_FirstDecl && k <= cursor_LastDecl) ||
  (k >= cursor_FirstExtraDecl && k <= cursor_LastExtraDecl)
{-# INLINE isDeclaration #-}

-- unsigned clang_isReference(enum CursorKind);
isReference :: CursorKind -> Bool
isReference k =
  (k >= cursor_FirstRef && k <= cursor_LastRef)
{-# INLINE isReference #-}

-- unsigned clang_isExpression(enum CursorKind);
isExpression :: CursorKind -> Bool
isExpression k =
  (k >= cursor_FirstExpr && k <= cursor_LastExpr)
{-# INLINE isExpression #-}

-- unsigned clang_isStatement(enum CursorKind);
isStatement :: CursorKind -> Bool
isStatement k =
  (k >= cursor_FirstStmt && k <= cursor_LastStmt)
{-# INLINE isStatement #-}

isAttribute :: CursorKind -> Bool
isAttribute k =
  (k >= cursor_FirstAttr && k <= cursor_LastAttr)
{-# INLINE isAttribute #-}
  
-- unsigned clang_isInvalid(enum CursorKind);
isInvalid :: CursorKind -> Bool
isInvalid k =
  (k >= cursor_FirstInvalid && k <= cursor_LastInvalid)
{-# INLINE isInvalid #-}

-- unsigned clang_isTranslationUnit(enum CursorKind);
isTranslationUnit :: CursorKind -> Bool
isTranslationUnit Cursor_TranslationUnit = True
isTranslationUnit _ = False
{-# INLINE isTranslationUnit #-}

-- unsigned clang_isPreprocessing(enum CursorKind);
isPreprocessing :: CursorKind -> Bool
isPreprocessing k =
  (k >= cursor_FirstPreprocessing && k <= cursor_LastPreprocessing)
{-# INLINE isPreprocessing #-}

-- unsigned clang_isUnexposed(enum CursorKind);
isUnexposed :: CursorKind -> Bool
isUnexposed k =
  (k >= cursor_FirstPreprocessing && k <= cursor_LastPreprocessing)
{-# INLINE isUnexposed #-}

-- enum CXLinkageKind {
--   CXLinkage_Invalid,
--   CXLinkage_NoLinkage,
--   CXLinkage_Internal,
--   CXLinkage_UniqueExternal,
--   CXLinkage_External
-- };
%enum LinkageKind (Bounded, Enum, Eq, Ord, Read, Show) Int [CXLinkage_Invalid,CXLinkage_NoLinkage,CXLinkage_Internal,CXLinkage_UniqueExternal,CXLinkage_External]

-- enum CXLinkageKind clang_getCursorLinkage(CXCursor cursor);
%fun clang_getCursorLinkage :: Cursor s -> IO LinkageKind
%call (cursor k xdata p1 p2 p3)
%code CXCursor a = {k, xdata, {p1, p2, p3}};
%     enum CXLinkageKind r = clang_getCursorLinkage(a);
%result (linkageKind r)

-- enum CXAvailabilityKind clang_getCursorAvailability(CXCursor cursor);
%fun clang_getCursorAvailability :: Cursor s -> IO AvailabilityKind
%call (cursor k xdata p1 p2 p3)
%code CXCursor a = {k, xdata, {p1, p2, p3}};
%     enum CXAvailabilityKind r = clang_getCursorAvailability(a);
%result (availabilityKind r)

-- enum CXLanguageKind {
--   CXLanguage_Invalid = 0,
--   CXLanguage_C,
--   CXLanguage_ObjC,
--   CXLanguage_CPlusPlus
-- };
%enum LanguageKind (Bounded, Enum, Eq, Ord, Read, Show) Int [CXLanguage_Invalid,CXLanguage_C,CXLanguage_ObjC,CXLanguage_CPlusPlus]

-- enum CXLanguageKind clang_getCursorLanguage(CXCursor cursor);
%fun clang_getCursorLanguage :: Cursor s -> IO LanguageKind
%call (cursor k xdata p1 p2 p3)
%code CXCursor a = {k, xdata, {p1, p2, p3}};
%     enum CXLanguageKind r = clang_getCursorLanguage(a);
%result (languageKind r)

-- CXTranslationUnit clang_Cursor_getTranslationUnit(CXCursor);
%fun unsafe_Cursor_getTranslationUnit :: Cursor s -> IO (TranslationUnit ())
%call (cursor k xdata p1 p2 p3)
%code CXCursor a = {k, xdata, {p1, p2, p3}};
%     CXTranslationUnit r = clang_Cursor_getTranslationUnit(a);
%result (translationUnit r)

-- Note that we do not register the translation unit! This function
-- never creates a 'new' translation unit, so we don't need to dispose
-- it. Moreover, since translation units aren't reference counted doing
-- so will lead to crashes.
cursor_getTranslationUnit :: ClangBase m => Cursor s' -> ClangT s m (TranslationUnit s)
cursor_getTranslationUnit c = liftIO $ unsafeCoerce <$> unsafe_Cursor_getTranslationUnit c

-- typedef struct CXCursorSetImpl *CXCursorSet;
newtype CursorSet s = CursorSet { unCursorSet :: Ptr () }

-- void clang_disposeCXCursorSet(CXCursorSet cset);
%fun clang_disposeCXCursorSet :: CursorSet s -> IO ()
%call (cursorSet cs)
%code clang_disposeCXCursorSet(cs);

registerCursorSet :: ClangBase m => IO (CursorSet ()) -> ClangT s m (CursorSet s)
registerCursorSet action = do
  (_, idx) <- clangAllocate (action >>= return . unsafeCoerce)
                            (\i -> disposeCXCursorSet i)
  return idx
{-# INLINEABLE registerCursorSet #-}

%dis cursorSet cs = <unCursorSet/CursorSet> (ptr cs)

-- CXCursorSet clang_createCXCursorSet();
%fun unsafe_createCXCursorSet :: IO (CursorSet ())
%code CXCursorSet cs = clang_createCXCursorSet();
%result (cursorSet cs)

createCXCursorSet :: ClangBase m => ClangT s m (CursorSet s)
createCXCursorSet = registerCursorSet unsafe_createCXCursorSet

-- unsigned clang_CXCursorSet_contains(CXCursorSet cset, CXCursor cursor);
%fun clang_CXCursorSet_contains :: CursorSet s -> Cursor s' -> IO Bool
%call (cursorSet cs) (cursor k xdata p1 p2 p3)
%code CXCursor a = {k, xdata, {p1, p2, p3}};
%result (bool {clang_CXCursorSet_contains(cs, a)})

-- unsigned clang_CXCursorSet_insert(CXCursorSet cset, CXCursor cursor);
%fun clang_CXCursorSet_insert :: CursorSet s -> Cursor s' -> IO Bool
%call (cursorSet cs) (cursor k xdata p1 p2 p3)
%code CXCursor a = {k, xdata, {p1, p2, p3}};
%result (bool {clang_CXCursorSet_insert(cs, a)})

-- CXCursor clang_getCursorSemanticParent(CXCursor cursor);
%fun clang_getCursorSemanticParent :: Proxy s -> Cursor s' -> IO (Cursor s)
%call (proxy) (cursor k xdata p1 p2 p3)
%code CXCursor a = {k, xdata, {p1, p2, p3}};
%     CXCursor r = clang_getCursorSemanticParent(a);
%result (cursor {r.kind} {r.xdata} {r.data[0]} {r.data[1]} {r.data[2]})

-- CXCursor clang_getCursorLexicalParent(CXCursor cursor);
%fun clang_getCursorLexicalParent :: Proxy s -> Cursor s' -> IO (Cursor s)
%call (proxy) (cursor k xdata p1 p2 p3)
%code CXCursor a = {k, xdata, {p1, p2, p3}};
%     CXCursor r = clang_getCursorLexicalParent(a);
%result (cursor {r.kind} {r.xdata} {r.data[0]} {r.data[1]} {r.data[2]})

-- void clang_disposeOverriddenCursors(CXCursor *overridden);
%fun disposeOverridden :: CursorList s -> IO ()
%call (cursorList cs n)
%code clang_disposeOverriddenCursors(cs);
  
registerOverriddenList :: ClangBase m => IO UnsafeCursorList -> ClangT s m (CursorList s)
registerOverriddenList action = do
    (_, cursorList) <- clangAllocate (action >>= cursorListToVector) disposeOverridden
    return cursorList
{-# INLINEABLE registerOverriddenList #-}

-- void clang_getOverriddenCursors(CXCursor cursor, CXCursor **overridden, unsigned *num_overridden);
%fun unsafe_getOverriddenCursors :: Cursor s -> IO UnsafeCursorList
%call (cursor k xdata p1 p2 p3)
%code CXCursor a = {k , xdata, {p1, p2, p3}};
%     CXCursor* overrides; unsigned count;
%     clang_getOverriddenCursors(a, &overrides, &count);
%result (cursorList overrides count)

getOverriddenCursors :: ClangBase m => Cursor s' -> ClangT s m (CursorList s)
getOverriddenCursors = registerOverriddenList . unsafe_getOverriddenCursors

-- CXFile clang_getIncludedFile(CXCursor cursor);
%fun clang_getIncludedFile :: Proxy s -> Cursor s' -> IO (File s)
%call (proxy) (cursor k xdata p1 p2 p3)
%code CXCursor a = {k, xdata, {p1, p2, p3}};
%result (file {clang_getIncludedFile(a)})

-- CXCursor clang_getCursor(CXTranslationUnit, CXSourceLocation);
%fun clang_getCursor :: Proxy s -> TranslationUnit s' -> SourceLocation s'' -> IO (Cursor s)
%call (proxy) (translationUnit t) (sourceLocation p1 p2 d)
%code CXSourceLocation l = {{p1, p2}, d};
%     CXCursor r = clang_getCursor(t, l);
%result (cursor {r.kind} {r.xdata} {r.data[0]} {r.data[1]} {r.data[2]})

-- CXSourceLocation clang_getCursorLocation(CXCursor);
%fun clang_getCursorLocation :: Proxy s -> Cursor s' -> IO (SourceLocation s)
%call (proxy) (cursor k xdata p1 p2 p3)
%code CXCursor a = {k, xdata, {p1, p2, p3}};
%     CXSourceLocation r = clang_getCursorLocation(a);
%result (sourceLocation {r.ptr_data[0]} {r.ptr_data[1]} {r.int_data})
{-# INLINEABLE getCursorLocation #-}

-- Variant of clang_getCursorLocation that fuses a call to clang_getSpellingLocation.
%fun clang_getCursorSpellingLocation :: Proxy s -> Cursor s' -> IO (Maybe (File s), Int, Int, Int)
%call (proxy) (cursor k xdata p1 p2 p3)
%code CXCursor a = {k, xdata, {p1, p2, p3}};
%     CXSourceLocation l = clang_getCursorLocation(a);
%     CXFile f; unsigned ln, c, o;
%     clang_getSpellingLocation(l, &f, &ln, &c, &o);
%result ((maybe_file f), (int ln), (int c), (int o))
{-# INLINEABLE getCursorSpellingLocation #-}

-- CXSourceRange clang_getCursorExtent(CXCursor);
%fun clang_getCursorExtent :: Proxy s -> Cursor s' -> IO (SourceRange s)
%call (proxy) (cursor k xdata p1 p2 p3)
%code CXCursor a = {k, xdata, {p1, p2, p3}};
%     CXSourceRange r = clang_getCursorExtent(a);
%result (sourceRange {r.ptr_data[0]} {r.ptr_data[1]} {r.begin_int_data} {r.end_int_data})
{-# INLINEABLE getCursorExtent #-}

-- enum CXTypeKind {
--   CXType_Invalid = 0,
--   CXType_Unexposed = 1,
--   CXType_Void = 2,
--   CXType_Bool = 3,
--   CXType_Char_U = 4,
--   CXType_UChar = 5,
--   CXType_Char16 = 6,
--   CXType_Char32 = 7,
--   CXType_UShort = 8,
--   CXType_UInt = 9,
--   CXType_ULong = 10,
--   CXType_ULongLong = 11,
--   CXType_UInt128 = 12,
--   CXType_Char_S = 13,
--   CXType_SChar = 14,
--   CXType_WChar = 15,
--   CXType_Short = 16,
--   CXType_Int = 17,
--   CXType_Long = 18,
--   CXType_LongLong = 19,
--   CXType_Int128 = 20,
--   CXType_Float = 21,
--   CXType_Double = 22,
--   CXType_LongDouble = 23,
--   CXType_NullPtr = 24,
--   CXType_Overload = 25,
--   CXType_Dependent = 26,
--   CXType_ObjCId = 27,
--   CXType_ObjCClass = 28,
--   CXType_ObjCSel = 29,
--   CXType_FirstBuiltin = CXType_Void,
--   CXType_LastBuiltin  = CXType_ObjCSel,
--   CXType_Complex = 100,
--   CXType_Pointer = 101,
--   CXType_BlockPointer = 102,
--   CXType_LValueReference = 103,
--   CXType_RValueReference = 104,
--   CXType_Record = 105,
--   CXType_Enum = 106,
--   CXType_Typedef = 107,
--   CXType_ObjCInterface = 108,
--   CXType_ObjCObjectPointer = 109,
--   CXType_FunctionNoProto = 110,
--   CXType_FunctionProto = 111
--   CXType_ConstantArray = 112
--   CXType_Vector = 113,
--   CXType_IncompleteArray = 114,
--   CXType_VariableArray = 115,
--   CXType_DependentSizedArray = 116,
--   CXType_MemberPointer = 117
-- };

%enum TypeKind (Bounded, Enum, Eq, Ord, Read, Show) Int [CXType_Invalid,CXType_Unexposed,CXType_Void,CXType_Bool,CXType_Char_U,CXType_UChar,CXType_Char16,CXType_Char32,CXType_UShort,CXType_UInt,CXType_ULong,CXType_ULongLong,CXType_UInt128,CXType_Char_S,CXType_SChar,CXType_WChar,CXType_Short,CXType_Int,CXType_Long,CXType_LongLong,CXType_Int128,CXType_Float,CXType_Double,CXType_LongDouble,CXType_NullPtr,CXType_Overload,CXType_Dependent,CXType_ObjCId,CXType_ObjCClass,CXType_ObjCSel,CXType_Complex,CXType_Pointer,CXType_BlockPointer,CXType_LValueReference,CXType_RValueReference,CXType_Record,CXType_Enum,CXType_Typedef,CXType_ObjCInterface,CXType_ObjCObjectPointer,CXType_FunctionNoProto,CXType_FunctionProto,CXType_ConstantArray,CXType_Vector,CXType_IncompleteArray,CXType_VariableArray,CXType_DependentSizedArray,CXType_MemberPointer]

type_FirstBuiltin, type_LastBuiltin :: TypeKind
type_FirstBuiltin = Type_Void
type_LastBuiltin  = Type_ObjCSel

-- enum CXCallingConv {
--   CXCallingConv_Default = 0,
--   CXCallingConv_C = 1,
--   CXCallingConv_X86StdCall = 2,
--   CXCallingConv_X86FastCall = 3,
--   CXCallingConv_X86ThisCall = 4,
--   CXCallingConv_X86Pascal = 5,
--   CXCallingConv_AAPCS = 6,
--   CXCallingConv_AAPCS_VFP = 7,
--   CXCallingConv_PnaclCall = 8,
--   CXCallingConv_IntelOclBicc = 9,
--   CXCallingConv_X86_64Win64 = 10,
--   CXCallingConv_X86_64SysV = 11,
--   CXCallingConv_Invalid = 100,
--   CXCallingConv_Unexposed = 200
-- };
%enum CallingConv (Bounded, Enum, Eq, Ord, Read, Show) Int [CXCallingConv_Default, CXCallingConv_C, CXCallingConv_X86StdCall, CXCallingConv_X86FastCall, CXCallingConv_X86ThisCall, CXCallingConv_X86Pascal, CXCallingConv_AAPCS, CXCallingConv_AAPCS_VFP, CXCallingConv_PnaclCall, CXCallingConv_IntelOclBicc, CXCallingConv_X86_64Win64, CXCallingConv_X86_64SysV, CXCallingConv_Invalid, CXCallingConv_Unexposed]

-- typedef struct {
--   enum CXTypeKind kind;
--   void *data[2];
-- } CXType;
data Type s = Type !TypeKind !(Ptr ()) !(Ptr ())
%dis type k p1 p2 = Type (typeKind k) (ptr p1) (ptr p2)

getTypeKind (Type k _ _) = k

-- CXType clang_getCursorType(CXCursor C);
%fun clang_getCursorType :: Proxy s -> Cursor s' -> IO (Type s)
%call (proxy) (cursor k xdata p1 p2 p3)
%code CXCursor a = {k, xdata, {p1, p2, p3}};
%     CXType r = clang_getCursorType(a);
%result (type {r.kind} {r.data[0]} {r.data[1]})

-- CXString clang_getTypeSpelling(CXType CT);
%fun unsafe_getTypeSpelling :: (Type s) -> IO (CXString ())
%call (type k p1 p2)
%code CXType t = {k, {p1, p2}};
%     CXString out = clang_getTypeSpelling(t);
%     const void* outData = out.data;
%     unsigned outFlags = out.private_flags;
%result (cxString (ptr outData) (word32 outFlags))

getTypeSpelling :: ClangBase m => (Type s') -> ClangT s m (CXString s)
getTypeSpelling = registerCXString . unsafe_getTypeSpelling

-- CXType clang_getTypedefDeclUnderlyingType(CXCursor C);
%fun clang_getTypedefDeclUnderlyingType :: Proxy s -> Cursor s' -> IO (Type s)
%call (proxy) (cursor k xdata p1 p2 p3)
%code CXCursor a = {k, xdata, {p1, p2, p3}};
%     CXType r = clang_getTypedefDeclUnderlyingType(a);
%result (type {r.kind} {r.data[0]} {r.data[1]})

-- CXType clang_getEnumDeclIntegerType(CXCursor C);
%fun clang_getEnumDeclIntegerType :: Proxy s -> Cursor s' -> IO (Type s)
%call (proxy) (cursor k xdata p1 p2 p3)
%code CXCursor a = {k, xdata, {p1, p2, p3}};
%     CXType r = clang_getEnumDeclIntegerType(a);
%result (type {r.kind} {r.data[0]} {r.data[1]})

%dis int64 x    = %%Int64 ({HsInt64} x)

-- long long clang_getEnumConstantDeclValue(CXCursor);
%fun clang_getEnumConstantDeclValue :: Cursor s -> IO Int64
%call (cursor k xdata p1 p2 p3)
%code CXCursor a = {k, xdata, {p1, p2, p3}};
%     r = clang_getEnumConstantDeclValue(a);
%result (int64 r)

-- unsigned long long clang_getEnumConstantDeclUnsignedValue(CXCursor);
%fun clang_getEnumConstantDeclUnsignedValue :: Cursor s -> IO Word64
%call (cursor k xdata p1 p2 p3)
%code CXCursor a = {k, xdata, {p1, p2, p3}};
%     r = clang_getEnumConstantDeclUnsignedValue(a);
%result (word64 r)

-- int clang_getFieldDeclBitWidth(CXCursor C);
%fun clang_getFieldDeclBitWidth :: Cursor s -> IO Int
%call (cursor k xdata p1 p2 p3)
%code CXCursor a = {k, xdata, {p1, p2, p3}};
%     r = clang_getFieldDeclBitWidth(a);
%result (int r)

-- int clang_Cursor_getNumArguments(CXCursor C);
%fun clang_cursor_getNumArguments :: Cursor s -> IO Int
%call (cursor k xdata p1 p2 p3)
%code CXCursor a = {k, xdata, {p1, p2, p3}};
%     r = clang_Cursor_getNumArguments(a);
%result (int r)

-- CXCursor clang_Cursor_getArgument(CXCursor C, unsigned i);
%fun clang_cursor_getArgument :: Proxy s -> Cursor s' -> Int -> IO (Cursor s)
%call (proxy) (cursor k xdata p1 p2 p3) (int i)
%code CXCursor a = {k, xdata, {p1, p2, p3}};
%     CXCursor r = clang_Cursor_getArgument(a, i);
%result (cursor {r.kind} {r.xdata} {r.data[0]} {r.data[1]} {r.data[2]})

-- unsigned clang_equalTypes(CXType A, CXType B);
%fun clang_equalTypes :: Type s -> Type s' -> IO Bool
%call (type k p1 p2) (type k2 p12 p22)
%code CXType a = {k, {p1, p2}};
%     CXType b = {k2, {p12, p22}};
%     r = clang_equalTypes(a, b);
%result (bool r)

-- CXType clang_getCanonicalType(CXType T);
%fun clang_getCanonicalType :: Proxy s -> Type s' -> IO (Type s)
%call (proxy) (type k p1 p2)
%code CXType a = {k, {p1, p2}};
%     CXType r = clang_getCanonicalType(a);
%result (type {r.kind} {r.data[0]} {r.data[1]})

-- unsigned clang_isConstQualifiedType(CXType T);
%fun clang_isConstQualifiedType :: Type s -> IO Bool
%call (type k p1 p2)
%code CXType a = {k, {p1, p2}};
%     r = clang_isConstQualifiedType(a);
%result (bool r)

-- unsigned clang_isVolatileQualifiedType(CXType T);
%fun clang_isVolatileQualifiedType :: Type s -> IO Bool
%call (type k p1 p2)
%code CXType a = {k, {p1, p2}};
%     r = clang_isVolatileQualifiedType(a);
%result (bool r)

-- unsigned clang_isRestrictQualifiedType(CXType T);
%fun clang_isRestrictQualifiedType :: Type s -> IO Bool
%call (type k p1 p2)
%code CXType a = {k, {p1, p2}};
%     r = clang_isRestrictQualifiedType(a);
%result (bool r)

-- CXType clang_getPointeeType(CXType T);
%fun clang_getPointeeType :: Proxy s -> Type s' -> IO (Type s)
%call (proxy) (type k p1 p2)
%code CXType a = {k, {p1, p2}};
%     CXType r = clang_getPointeeType(a);
%result (type {r.kind} {r.data[0]} {r.data[1]})

-- CXCursor clang_getTypeDeclaration(CXType T);
%fun clang_getTypeDeclaration :: Proxy s -> Type s' -> IO (Cursor s)
%call (proxy) (type k p1 p2)
%code CXType a = {k, {p1, p2}};
%     CXCursor r = clang_getTypeDeclaration(a);
%result (cursor {r.kind} {r.xdata} {r.data[0]} {r.data[1]} {r.data[2]})

-- CXString clang_getDeclObjCTypeEncoding(CXCursor C);
%fun unsafe_getDeclObjCTypeEncoding :: Cursor s -> IO (CXString ())
%call (cursor k xdata p1 p2 p3)
%code CXCursor a = {k, xdata, {p1, p2, p3}};
%     CXString out = clang_getDeclObjCTypeEncoding(a);
%     const void* outData = out.data;
%     unsigned outFlags = out.private_flags;
%result (cxString (ptr outData) (word32 outFlags))

getDeclObjCTypeEncoding :: ClangBase m => Cursor s' -> ClangT s m (CXString s)
getDeclObjCTypeEncoding = registerCXString . unsafe_getDeclObjCTypeEncoding

-- CXString clang_getTypeKindSpelling(enum CXTypeKind K);
%fun unsafe_getTypeKindSpelling :: TypeKind -> IO (CXString ())
%call (typeKind tk)
%code CXString out = clang_getTypeKindSpelling(tk);
%     const void* outData = out.data;
%     unsigned outFlags = out.private_flags;
%result (cxString (ptr outData) (word32 outFlags))

getTypeKindSpelling :: ClangBase m => TypeKind -> ClangT s m (CXString s)
getTypeKindSpelling = registerCXString . unsafe_getTypeKindSpelling

-- enum CXCallingConv clang_getFunctionTypeCallingConv(CXType T);
%fun clang_getFunctionTypeCallingConv :: Type s' -> IO CallingConv
%call (type k p1 p2)
%code CXType a = {k, {p1, p2}};
%     enum CXCallingConv r = clang_getFunctionTypeCallingConv(a);
%result (callingConv r)

-- CXType clang_getResultType(CXType T);
%fun clang_getResultType :: Proxy s -> Type s' -> IO (Type s)
%call (proxy) (type k p1 p2)
%code CXType a = {k, {p1, p2}};
%     CXType r = clang_getResultType(a);
%result (type {r.kind} {r.data[0]} {r.data[1]})

-- CXType clang_getNumArgTypes(CXType T);
%fun clang_getNumArgTypes :: Type s -> IO Int
%call (type k p1 p2)
%code CXType a = {k, {p1, p2}};
%     r = clang_getNumArgTypes(a);
%result (int r)

-- CXType clang_getArgType(CXType T, int i);
%fun clang_getArgType :: Proxy s -> Type s' -> Int -> IO (Type s)
%call (proxy) (type k p1 p2) (int i)
%code CXType a = {k, {p1, p2}};
%     CXType r = clang_getArgType(a, i);
%result (type {r.kind} {r.data[0]} {r.data[1]})

-- unsigned clang_isFunctionTypeVariadic(CXType T);
%fun clang_isFunctionTypeVariadic :: Type s -> IO Bool
%call (type k p1 p2)
%code CXType a = {k, {p1, p2}};
%     r = clang_isFunctionTypeVariadic(a);
%result (bool r)

-- CXType clang_getCursorResultType(CXCursor C);
%fun clang_getCursorResultType :: Proxy s -> Cursor s' -> IO (Type s)
%call (proxy) (cursor k xdata p1 p2 p3)
%code CXCursor a = {k, xdata, {p1, p2, p3}};
%     CXType r = clang_getCursorResultType(a);
%result (type {r.kind} {r.data[0]} {r.data[1]})

-- unsigned clang_isPODType(CXType T);
%fun clang_isPODType :: Type s -> IO Bool
%call (type k p1 p2)
%code CXType a = {k, {p1, p2}};
%     r = clang_isPODType(a);
%result (bool r)

-- CXType clang_getElementType(CXType T);
%fun clang_getElementType :: Proxy s -> Type s' -> IO (Type s)
%call (proxy) (type k p1 p2)
%code CXType a = {k, {p1, p2}};
%     CXType r = clang_getElementType(a);
%result (type {r.kind} {r.data[0]} {r.data[1]})

-- long long clang_getNumElements(CXType T);
%fun clang_getNumElements :: Type s -> IO Int64
%call (type k p1 p2)
%code CXType a = {k, {p1, p2}};
%     long long r = clang_getNumElements(a);
%result (int64 r)

-- CXType clang_getArrayElementType(CXType T);
%fun clang_getArrayElementType :: Proxy s -> Type s' -> IO (Type s)
%call (proxy) (type k p1 p2)
%code CXType a = {k, {p1, p2}};
%     CXType r = clang_getArrayElementType(a);
%result (type {r.kind} {r.data[0]} {r.data[1]})

-- long long clang_getArraySize(CXType T);
%fun clang_getArraySize :: Type s -> IO Int64
%call (type k p1 p2)
%code CXType a = {k, {p1, p2}};
%     long long r = clang_getArraySize(a);
%result (int64 r)

-- enum CXTypeLayoutError {
--   CXTypeLayoutError_Invalid = -1,
--   CXTypeLayoutError_Incomplete = -2,
--   CXTypeLayoutError_Dependent = -3,
--   CXTypeLayoutError_NotConstantSize = -4,
--   CXTypeLayoutError_InvalidFieldName = -5
-- };
%enum TypeLayoutError (Bounded, Enum, Eq, Ord, Read, Show) Int [CXTypeLayoutError_Invalid, CXTypeLayoutError_Incomplete, CXTypeLayoutError_Dependent, CXTypeLayoutError_NotConstantSize, CXTypeLayoutError_InvalidFieldName]

int64OrLayoutError :: Int64 -> Either TypeLayoutError Int64
int64OrLayoutError v | v == -1   = Left TypeLayoutError_Invalid
                     | v == -2   = Left TypeLayoutError_Incomplete
                     | v == -3   = Left TypeLayoutError_Dependent
                     | v == -4   = Left TypeLayoutError_NotConstantSize
                     | v == -5   = Left TypeLayoutError_InvalidFieldName
                     | otherwise = Right v

%dis int64_or_layoutError i = <id/int64OrLayoutError> (int64 i)

-- long long clang_Type_getAlignOf(CXType T);
%fun clang_Type_getAlignOf :: Type s -> IO (Either TypeLayoutError Int64)
%call (type k p1 p2)
%code CXType a = {k, {p1, p2}};
%     long long r = clang_Type_getAlignOf(a);
%result (int64_or_layoutError r)

-- CXType clang_Type_getClassType(CXType T);
%fun clang_Type_getClassType :: Proxy s -> Type s' -> IO (Type s)
%call (proxy) (type k p1 p2)
%code CXType a = {k, {p1, p2}};
%     CXType r = clang_Type_getClassType(a);
%result (type {r.kind} {r.data[0]} {r.data[1]})

-- long long clang_Type_getSizeOf(CXType T);
%fun clang_Type_getSizeOf :: Type s -> IO (Either TypeLayoutError Int64)
%call (type k p1 p2)
%code CXType a = {k, {p1, p2}};
%     long long r = clang_Type_getSizeOf(a);
%result (int64_or_layoutError r)

-- long long clang_Type_getOffsetOf(CXType T, const char *S);
%fun unsafe_Type_getOffsetOf :: Type s -> CString -> IO (Either TypeLayoutError Int64)
%call (type k p1 p2) (ptr f)
%code CXType a = {k, {p1, p2}};
%     long long r = clang_Type_getOffsetOf(a, f);
%result (int64_or_layoutError r)

type_getOffsetOf :: ClangBase m => Type s' -> B.ByteString
                 -> ClangT s m (Either TypeLayoutError Int64)
type_getOffsetOf t field = liftIO $ B.useAsCString field $ \cField ->
  unsafe_Type_getOffsetOf t cField

-- enum CXRefQualifierKind {
--   CXRefQualifier_None = 0,
--   CXRefQualifier_LValue,
--   CXRefQualifier_RValue
-- };
%enum RefQualifierKind (Bounded, Enum, Eq, Ord, Read, Show) Int [CXRefQualifier_None, CXRefQualifier_LValue, CXRefQualifier_RValue]

-- enum CXRefQualifierKind clang_Type_getCXXRefQualifier(CXType T);
%fun clang_Type_getCXXRefQualifier :: Type s -> IO RefQualifierKind
%call (type k p1 p2)
%code CXType a = {k, {p1, p2}};
%     enum CXRefQualifierKind r = clang_Type_getCXXRefQualifier(a);
%result (refQualifierKind r)

-- unsigned clang_Cursor_isBitField(CXCursor C);
%fun clang_isBitField :: Cursor s -> IO Bool
%call (cursor k xdata p1 p2 p3)
%code CXCursor a = {k, xdata, {p1, p2, p3}};
%     r = clang_Cursor_isBitField(a);
%result (bool r)

-- unsigned clang_isVirtualBase(CXCursor);
%fun clang_isVirtualBase :: Cursor s -> IO Bool
%call (cursor k xdata p1 p2 p3)
%code CXCursor a = {k, xdata, {p1, p2, p3}};
%     r = clang_isVirtualBase(a);
%result (bool r)
    
-- enum CX_CXXAccessSpecifier {
--   CX_CXXInvalidAccessSpecifier,
--   CX_CXXPublic,
--   CX_CXXProtected,
--   CX_CXXPrivate
-- };
%enum CXXAccessSpecifier (Bounded, Enum, Eq, Ord, Read, Show) Int [CX_CXXInvalidAccessSpecifier, CX_CXXPublic, CX_CXXProtected, CX_CXXPrivate]

-- enum CX_CXXAccessSpecifier clang_getCXXAccessSpecifier(CXCursor);
%fun clang_getCXXAccessSpecifier :: Cursor s -> IO CXXAccessSpecifier
%call (cursor k xdata p1 p2 p3)
%code CXCursor a = {k, xdata, {p1, p2, p3}};
%     r = clang_getCXXAccessSpecifier(a);
%result (cXXAccessSpecifier r)

-- unsigned clang_getNumOverloadedDecls(CXCursor cursor);
%fun clang_getNumOverloadedDecls :: Cursor s -> IO Int
%call (cursor k xdata p1 p2 p3)
%code CXCursor a = {k, xdata, {p1, p2, p3}};
%     r = clang_getNumOverloadedDecls(a);
%result (int r)

-- CXCursor clang_getOverloadedDecl(CXCursor cursor, 
--                                                 unsigned index);
%fun clang_getOverloadedDecl :: Proxy s -> Cursor s' -> Int -> IO (Cursor s)
%call (proxy) (cursor k xdata p1 p2 p3) (int i)
%code CXCursor a = {k, xdata, {p1, p2, p3}};
%     CXCursor r = clang_getOverloadedDecl(a, i);
%result (cursor {r.kind} {r.xdata} {r.data[0]} {r.data[1]} {r.data[2]})

-- CXType clang_getIBOutletCollectionType(CXCursor);
%fun clang_getIBOutletCollectionType :: Proxy s -> Cursor s' -> IO (Type s)
%call (proxy) (cursor k xdata p1 p2 p3)
%code CXCursor a = {k, xdata, {p1, p2, p3}};
%     CXType r = clang_getIBOutletCollectionType(a);
%result (type {r.kind} {r.data[0]} {r.data[1]})

-- We deliberately don't export the constructor. The only way to unwrap this is registerCursorList.
type CursorList s = DVS.Vector (Cursor s)
data UnsafeCursorList = UnsafeCursorList !(Ptr ()) !Int

-- void freeCursorList(CXCursor* cursors);
%fun freeCursorList :: CursorList s -> IO ()
%call (cursorList cs n)
%code freeCursorList(cs);

registerCursorList :: ClangBase m => IO UnsafeCursorList -> ClangT s m (CursorList s)
registerCursorList action = do
    (_, cursorList) <- clangAllocate (action >>= cursorListToVector) freeCursorList
    return cursorList
{-# INLINEABLE registerCursorList #-}

cursorListToVector :: Storable a => UnsafeCursorList -> IO (DVS.Vector a)
cursorListToVector (UnsafeCursorList cs n) = do
  fptr <- newForeignPtr_ (castPtr cs)
  return $ DVS.unsafeFromForeignPtr fptr 0 n
{-# INLINE cursorListToVector #-}

fromCursorList :: CursorList s -> (Ptr (), Int)
fromCursorList cs = let (p, _, _) = DVS.unsafeToForeignPtr cs in
                   (castPtr $ Foreign.ForeignPtr.Unsafe.unsafeForeignPtrToPtr p, DVS.length cs)

toCursorList :: (Ptr (), Int) -> UnsafeCursorList
toCursorList (cs, n) = UnsafeCursorList cs n

%dis cursorList cs n = <fromCursorList/toCursorList> (ptr cs) (int n)

-- A more efficient alternative to clang_visitChildren.
-- void getChildren(CXCursor parent, CXCursor** childrenOut, unsigned* countOut)
%fun unsafe_getChildren :: Cursor s -> IO UnsafeCursorList
%call (cursor k xdata p1 p2 p3)
%code CXCursor c = {k, xdata, {p1, p2, p3}};
%     CXCursor* children; unsigned count;
%     getChildren(c, &children, &count);
%result (cursorList children count)

getChildren :: ClangBase m => Cursor s' -> ClangT s m (CursorList s)
getChildren = registerCursorList . unsafe_getChildren

-- Like getChildren, but gets all transitive descendants.
-- void getDescendants(CXCursor parent, CXCursor** childrenOut, unsigned* countOut)
%fun unsafe_getDescendants :: Cursor s -> IO UnsafeCursorList
%call (cursor k xdata p1 p2 p3)
%code CXCursor c = {k, xdata, {p1, p2, p3}};
%     CXCursor* children; unsigned count;
%     getDescendants(c, &children, &count);
%result (cursorList children count)

getDescendants :: ClangBase m => Cursor s' -> ClangT s m (CursorList s)
getDescendants = registerCursorList . unsafe_getDescendants

data ParentedCursor s = ParentedCursor
  { parentCursor :: !(Cursor s)
  , childCursor  :: !(Cursor s)
  }

instance Storable (ParentedCursor s) where
    sizeOf _ = sizeOfParentedCursor
    {-# INLINE sizeOf #-}

    alignment _ = alignOfParentedCursor
    {-# INLINE alignment #-}

    peek p = do
      parent <- peekByteOff p offsetParentedCursorParent
      child <- peekByteOff p offsetParentedCursorCursor
      return $! ParentedCursor parent child
    {-# INLINE peek #-}

    poke p (ParentedCursor parent child) = do
      pokeByteOff p offsetParentedCursorParent parent
      pokeByteOff p offsetParentedCursorCursor child
    {-# INLINE poke #-}

-- We deliberately don't export the constructor. The only way to unwrap this is registerParentedCursorList.
type ParentedCursorList s = DVS.Vector (ParentedCursor s)
data UnsafeParentedCursorList = UnsafeParentedCursorList !(Ptr ()) !Int

-- void freeParentedCursorList(struct ParentedCursor* parentedCursors);
%fun freeParentedCursorList :: ParentedCursorList s -> IO ()
%call (parentedCursorList cs n)
%code freeParentedCursorList(cs);

registerParentedCursorList :: ClangBase m => IO UnsafeParentedCursorList
                           -> ClangT s m (ParentedCursorList s)
registerParentedCursorList action = do
    (_, pcList) <- clangAllocate (action >>= mkSafe) freeParentedCursorList
    return pcList
  where
    mkSafe (UnsafeParentedCursorList cs n) = do
      fptr <- newForeignPtr_ (castPtr cs)
      return $ DVS.unsafeFromForeignPtr fptr 0 n
{-# INLINEABLE registerParentedCursorList #-}

fromParentedCursorList :: ParentedCursorList s -> (Ptr (), Int)
fromParentedCursorList cs =
  let (p, _, _) = DVS.unsafeToForeignPtr cs in
  (castPtr $ Foreign.ForeignPtr.Unsafe.unsafeForeignPtrToPtr p, DVS.length cs)

toParentedCursorList :: (Ptr (), Int) -> UnsafeParentedCursorList
toParentedCursorList (cs, n) = UnsafeParentedCursorList cs n

%dis parentedCursorList cs n = <fromParentedCursorList/toParentedCursorList> (ptr cs) (int n)

-- Like getParentedDescendants, but pairs each descendant with its parent.
-- void getParentedDescendants(CXCursor parent, struct ParentedCursor** descendantsOut,
--                             unsigned* countOut)
%fun unsafe_getParentedDescendants :: Cursor s -> IO UnsafeParentedCursorList
%call (cursor k xdata p1 p2 p3)
%code CXCursor c = {k, xdata, {p1, p2, p3}};
%     struct ParentedCursor* descendants; unsigned count;
%     getParentedDescendants(c, &descendants, &count);
%result (parentedCursorList descendants count)

getParentedDescendants :: ClangBase m => Cursor s' -> ClangT s m (ParentedCursorList s)
getParentedDescendants = registerParentedCursorList . unsafe_getParentedDescendants

-- CXString clang_getCursorUSR(CXCursor);
%fun unsafe_getCursorUSR :: Cursor s -> IO (CXString ())
%call (cursor k xdata p1 p2 p3)
%code CXCursor a = {k, xdata, {p1, p2, p3}};
%     CXString out = clang_getCursorUSR(a);
%     const void* outData = out.data;
%     unsigned outFlags = out.private_flags;
%result (cxString (ptr outData) (word32 outFlags))

getCursorUSR :: ClangBase m => Cursor s' -> ClangT s m (CXString s)
getCursorUSR = registerCXString . unsafe_getCursorUSR

-- CXString clang_constructUSR_ObjCClass(const char *class_name);
%fun unsafe_constructUSR_ObjCClass :: String -> IO (CXString ())
%call (string s)
%code CXString out = clang_constructUSR_ObjCClass(s);
%     const void* outData = out.data;
%     unsigned outFlags = out.private_flags;
%result (cxString (ptr outData) (word32 outFlags))

constructUSR_ObjCClass :: ClangBase m => String -> ClangT s m (CXString s)
constructUSR_ObjCClass = registerCXString . unsafe_constructUSR_ObjCClass

-- CXString
--   clang_constructUSR_ObjCCategory(const char *class_name,
--                                  const char *category_name);
%fun unsafe_constructUSR_ObjCCategory :: String -> String -> IO (CXString ())
%call (string s) (string p)
%code CXString out = clang_constructUSR_ObjCCategory(s, p);
%     const void* outData = out.data;
%     unsigned outFlags = out.private_flags;
%result (cxString (ptr outData) (word32 outFlags))

constructUSR_ObjCCategory :: ClangBase m => String -> String -> ClangT s m (CXString s)
constructUSR_ObjCCategory = (registerCXString .) . unsafe_constructUSR_ObjCCategory

-- CXString
--   clang_constructUSR_ObjCProtocol(const char *protocol_name);
%fun unsafe_constructUSR_ObjCProtocol :: String -> IO (CXString ())
%call (string s)
%code CXString out = clang_constructUSR_ObjCProtocol(s);
%     const void* outData = out.data;
%     unsigned outFlags = out.private_flags;
%result (cxString (ptr outData) (word32 outFlags))

constructUSR_ObjCProtocol :: ClangBase m => String -> ClangT s m (CXString s)
constructUSR_ObjCProtocol = registerCXString . unsafe_constructUSR_ObjCProtocol

-- CXString clang_constructUSR_ObjCIvar(const char *name,
--                                                     CXString classUSR);
%fun unsafe_constructUSR_ObjCIvar :: String -> Ptr () -> Word32 -> IO (CXString ())
%call (string s) (ptr d) (word32 f)
%code CXString str;
%     str.data = d;
%     str.private_flags = f;
%     CXString out = clang_constructUSR_ObjCIvar(s, str);
%     const void* outData = out.data;
%     unsigned outFlags = out.private_flags;
%result (cxString (ptr outData) (word32 outFlags))

constructUSR_ObjCIvar :: ClangBase m => String -> CXString s' -> ClangT s m (CXString s)
constructUSR_ObjCIvar s (CXString d f) = registerCXString $ unsafe_constructUSR_ObjCIvar s d f

-- CXString clang_constructUSR_ObjCMethod(const char *name,
--                                                       unsigned isInstanceMethod,
--                                                       CXString classUSR);
%fun unsafe_constructUSR_ObjCMethod :: String -> Bool -> Ptr () -> Word32 -> IO (CXString ())
%call (string s) (bool b) (ptr d) (word32 f)
%code CXString str;
%     str.data = d;
%     str.private_flags = f;
%     CXString out = clang_constructUSR_ObjCMethod(s, b, str);
%     const void* outData = out.data;
%     unsigned outFlags = out.private_flags;
%result (cxString (ptr outData) (word32 outFlags))

constructUSR_ObjCMethod :: ClangBase m => String -> Bool -> CXString s' -> ClangT s m (CXString s)
constructUSR_ObjCMethod s b (CXString d f) =
  registerCXString $ unsafe_constructUSR_ObjCMethod s b d f

-- CXString clang_constructUSR_ObjCProperty(const char *property,
--                                                         CXString classUSR);
%fun unsafe_constructUSR_ObjCProperty :: String -> Ptr () -> Word32 -> IO (CXString ())
%call (string s) (ptr d) (word32 f)
%code CXString str;
%     str.data = d;
%     str.private_flags = f;
%     CXString out = clang_constructUSR_ObjCProperty(s, str);
%     const void* outData = out.data;
%     unsigned outFlags = out.private_flags;
%result (cxString (ptr outData) (word32 outFlags))

constructUSR_ObjCProperty :: ClangBase m => String -> CXString s' -> ClangT s m (CXString s)
constructUSR_ObjCProperty s (CXString d f) =
  registerCXString $ unsafe_constructUSR_ObjCProperty s d f

-- CXString clang_getCursorSpelling(CXCursor);
%fun unsafe_getCursorSpelling :: Cursor s -> IO (CXString ())
%call (cursor k xdata p1 p2 p3)
%code CXCursor a = {k, xdata, {p1, p2, p3}};
%     CXString out = clang_getCursorSpelling(a);
%     const void* outData = out.data;
%     unsigned outFlags = out.private_flags;
%result (cxString (ptr outData) (word32 outFlags))

getCursorSpelling :: ClangBase m => Cursor s' -> ClangT s m (CXString s)
getCursorSpelling = registerCXString . unsafe_getCursorSpelling

-- CXSourceRange clang_Cursor_getSpellingNameRange(CXCursor,
--                                                 unsigned pieceIndex,
--                                                 unsigned options);
%fun clang_Cursor_getSpellingNameRange :: Proxy s -> Cursor s' -> Int -> IO (SourceRange s)
%call (proxy) (cursor k xdata p1 p2 p3) (int idx)
%code CXCursor a = {k, xdata, {p1, p2, p3}};
%     CXSourceRange r = clang_Cursor_getSpellingNameRange(a, idx, 0);
%result (sourceRange {r.ptr_data[0]} {r.ptr_data[1]} {r.begin_int_data} {r.end_int_data})

-- CXString clang_getCursorDisplayName(CXCursor);
%fun unsafe_getCursorDisplayName :: Cursor s -> IO (CXString ())
%call (cursor k xdata p1 p2 p3)
%code CXCursor a = {k, xdata, {p1, p2, p3}};
%     CXString out = clang_getCursorDisplayName(a);
%     const void* outData = out.data;
%     unsigned outFlags = out.private_flags;
%result (cxString (ptr outData) (word32 outFlags))

getCursorDisplayName :: ClangBase m => Cursor s' -> ClangT s m (CXString s)
getCursorDisplayName = registerCXString . unsafe_getCursorDisplayName
  
-- CXCursor clang_getCursorReferenced(CXCursor);
%fun clang_getCursorReferenced :: Proxy s -> Cursor s' -> IO (Cursor s)
%call (proxy) (cursor k xdata p1 p2 p3)
%code CXCursor a = {k, xdata, {p1, p2, p3}};
%     CXCursor r = clang_getCursorReferenced(a);
%result (cursor {r.kind} {r.xdata} {r.data[0]} {r.data[1]} {r.data[2]})

-- CXCursor clang_getCursorDefinition(CXCursor);
%fun clang_getCursorDefinition :: Proxy s -> Cursor s' -> IO (Cursor s)
%call (proxy) (cursor k xdata p1 p2 p3)
%code CXCursor a = {k, xdata, {p1, p2, p3}};
%     CXCursor r = clang_getCursorDefinition(a);
%result (cursor {r.kind} {r.xdata} {r.data[0]} {r.data[1]} {r.data[2]})

-- unsigned clang_isCursorDefinition(CXCursor);
%fun clang_isCursorDefinition :: Cursor s -> IO Bool
%call (cursor k xdata p1 p2 p3)
%code CXCursor a = {k, xdata, {p1, p2, p3}};
%     r = clang_isCursorDefinition(a);
%result (bool r)

-- unsigned clang_Cursor_isDynamicCall(CXCursor);
%fun clang_cursor_isDynamicCall :: Cursor s -> IO Bool
%call (cursor k xdata p1 p2 p3)
%code CXCursor a = {k, xdata, {p1, p2, p3}};
%     r = clang_Cursor_isDynamicCall(a);
%result (bool r)

-- CXCursor clang_getCanonicalCursor(CXCursor);
%fun clang_getCanonicalCursor :: Proxy s -> Cursor s' -> IO (Cursor s)
%call (proxy) (cursor k xdata p1 p2 p3)
%code CXCursor a = {k, xdata, {p1, p2, p3}};
%     CXCursor r = clang_getCanonicalCursor(a);
%result (cursor {r.kind} {r.xdata} {r.data[0]} {r.data[1]} {r.data[2]})

-- int clang_Cursor_getObjCSelectorIndex(CXCursor);
%fun clang_Cursor_getObjCSelectorIndex :: Cursor s -> IO Int
%call (cursor k xdata p1 p2 p3)
%code CXCursor a = {k, xdata, {p1, p2, p3}};
%     int r = clang_Cursor_getObjCSelectorIndex(a);
%result (int r)

-- CXType clang_Cursor_getReceiverType(CXCursor C);
%fun clang_Cursor_getReceiverType :: Proxy s -> Cursor s' -> IO (Type s)
%call (proxy) (cursor k xdata p1 p2 p3)
%code CXCursor a = {k, xdata, {p1, p2, p3}};
%     CXType r = clang_Cursor_getReceiverType(a);
%result (type {r.kind} {r.data[0]} {r.data[1]})

-- typedef enum {
--   CXObjCPropertyAttr_noattr    = 0x00,
--   CXObjCPropertyAttr_readonly  = 0x01,
--   CXObjCPropertyAttr_getter    = 0x02,
--   CXObjCPropertyAttr_assign    = 0x04,
--   CXObjCPropertyAttr_readwrite = 0x08,
--   CXObjCPropertyAttr_retain    = 0x10,
--   CXObjCPropertyAttr_copy      = 0x20,
--   CXObjCPropertyAttr_nonatomic = 0x40,
--   CXObjCPropertyAttr_setter    = 0x80,
--   CXObjCPropertyAttr_atomic    = 0x100,
--   CXObjCPropertyAttr_weak      = 0x200,
--   CXObjCPropertyAttr_strong    = 0x400,
--   CXObjCPropertyAttr_unsafe_unretained = 0x800
-- } CXObjCPropertyAttrKind;

%enum ObjCPropertyAttrKind (Bounded, Enum, Eq, Ord, Read, Show) Int [CXObjCPropertyAttr_noattr,CXObjCPropertyAttr_readonly,CXObjCPropertyAttr_getter,CXObjCPropertyAttr_assign,CXObjCPropertyAttr_readwrite,CXObjCPropertyAttr_retain,CXObjCPropertyAttr_copy,CXObjCPropertyAttr_nonatomic,CXObjCPropertyAttr_setter,CXObjCPropertyAttr_atomic,CXObjCPropertyAttr_weak,CXObjCPropertyAttr_strong,CXObjCPropertyAttr_unsafe_unretained]

instance BitFlags ObjCPropertyAttrKind where
  toBit ObjCPropertyAttr_noattr            = 0x0
  toBit ObjCPropertyAttr_readonly          = 0x1
  toBit ObjCPropertyAttr_getter            = 0x2
  toBit ObjCPropertyAttr_assign            = 0x4
  toBit ObjCPropertyAttr_readwrite         = 0x8
  toBit ObjCPropertyAttr_retain            = 0x10
  toBit ObjCPropertyAttr_copy              = 0x20
  toBit ObjCPropertyAttr_nonatomic         = 0x40
  toBit ObjCPropertyAttr_setter            = 0x80
  toBit ObjCPropertyAttr_atomic            = 0x100
  toBit ObjCPropertyAttr_weak              = 0x200
  toBit ObjCPropertyAttr_strong            = 0x400
  toBit ObjCPropertyAttr_unsafe_unretained = 0x800

-- unsigned clang_Cursor_getObjCPropertyAttributes(CXCursor C, unsigned reserved);
%fun clang_Cursor_getObjCPropertyAttributes :: Cursor s -> IO Int
%call (cursor k xdata p1 p2 p3)
%code CXCursor a = {k, xdata, {p1, p2, p3}};
%     unsigned r = clang_Cursor_getObjCPropertyAttributes(a, 0);
%result (int r)

-- typedef enum {
--   CXObjCDeclQualifier_None = 0x0,
--   CXObjCDeclQualifier_In = 0x1,
--   CXObjCDeclQualifier_Inout = 0x2,
--   CXObjCDeclQualifier_Out = 0x4,
--   CXObjCDeclQualifier_Bycopy = 0x8,
--   CXObjCDeclQualifier_Byref = 0x10,
--   CXObjCDeclQualifier_Oneway = 0x20
-- } CXObjCDeclQualifierKind;

%enum ObjCDeclQualifierKind (Bounded, Enum, Eq, Ord, Read, Show) Int [CXObjCDeclQualifier_None, CXObjCDeclQualifier_In, CXObjCDeclQualifier_Inout, CXObjCDeclQualifier_Out, CXObjCDeclQualifier_Bycopy, CXObjCDeclQualifier_Byref, CXObjCDeclQualifier_Oneway]

instance BitFlags ObjCDeclQualifierKind where
  toBit ObjCDeclQualifier_None   = 0x0
  toBit ObjCDeclQualifier_In     = 0x1
  toBit ObjCDeclQualifier_Inout  = 0x2
  toBit ObjCDeclQualifier_Out    = 0x4
  toBit ObjCDeclQualifier_Bycopy = 0x8
  toBit ObjCDeclQualifier_Byref  = 0x10
  toBit ObjCDeclQualifier_Oneway = 0x20

-- unsigned clang_Cursor_getObjCDeclQualifiers(CXCursor C);
%fun clang_Cursor_getObjCDeclQualifiers :: Cursor s -> IO Int
%call (cursor k xdata p1 p2 p3)
%code CXCursor a = {k, xdata, {p1, p2, p3}};
%     unsigned r = clang_Cursor_getObjCDeclQualifiers(a);
%result (int r)

-- unsigned clang_Cursor_isObjCOptional(CXCursor);
%fun clang_cursor_isObjCOptional :: Cursor s -> IO Bool
%call (cursor k xdata p1 p2 p3)
%code CXCursor a = {k, xdata, {p1, p2, p3}};
%     r = clang_Cursor_isObjCOptional(a);
%result (bool r)

-- unsigned clang_Cursor_isVariadic(CXCursor);
%fun clang_cursor_isVariadic :: Cursor s -> IO Bool
%call (cursor k xdata p1 p2 p3)
%code CXCursor a = {k, xdata, {p1, p2, p3}};
%     r = clang_Cursor_isVariadic(a);
%result (bool r)

-- CXSourceRange clang_Cursor_getCommentRange(CXCursor C);
%fun clang_Cursor_getCommentRange :: Proxy s -> Cursor s' -> IO (SourceRange s)
%call (proxy) (cursor k xdata p1 p2 p3)
%code CXCursor a = {k, xdata, {p1, p2, p3}};
%     CXSourceRange r = clang_Cursor_getCommentRange(a);
%result (sourceRange {r.ptr_data[0]} {r.ptr_data[1]} {r.begin_int_data} {r.end_int_data})

-- CXString clang_Cursor_getRawCommentText(CXCursor C);
%fun unsafe_Cursor_getRawCommentText :: Cursor s' -> IO (CXString ())
%call (cursor k xdata p1 p2 p3)
%code CXCursor a = {k, xdata, {p1, p2, p3}};
%     CXString out = clang_Cursor_getRawCommentText(a);
%     const void* outData = out.data;
%     unsigned outFlags = out.private_flags;
%result (cxString (ptr outData) (word32 outFlags))

cursor_getRawCommentText :: ClangBase m => Cursor s' -> ClangT s m (CXString s)
cursor_getRawCommentText = registerCXString . unsafe_Cursor_getRawCommentText

-- CXString clang_Cursor_getBriefCommentText(CXCursor C);
%fun unsafe_Cursor_getBriefCommentText :: Cursor s' -> IO (CXString ())
%call (cursor k xdata p1 p2 p3)
%code CXCursor a = {k, xdata, {p1, p2, p3}};
%     CXString out = clang_Cursor_getBriefCommentText(a);
%     const void* outData = out.data;
%     unsigned outFlags = out.private_flags;
%result (cxString (ptr outData) (word32 outFlags))

cursor_getBriefCommentText :: ClangBase m => Cursor s' -> ClangT s m (CXString s)
cursor_getBriefCommentText = registerCXString . unsafe_Cursor_getBriefCommentText

-- CXComment clang_Cursor_getParsedComment(CXCursor C);
%fun clang_Cursor_getParsedComment :: Proxy s -> Cursor s' -> IO (Comment s)
%call (proxy) (cursor k xdata p1 p2 p3)
%code CXCursor a = {k, xdata, {p1, p2, p3}};
%     CXComment r = clang_Cursor_getParsedComment(a);
%result (comment {r.ASTNode} {r.TranslationUnit})

-- typedef void *CXModule;
newtype Module s = Module { unModule :: Ptr () }

%dis cxmodule p = <unModule/Module> (ptr p)

maybeModule :: Module s' -> Maybe (Module s)
maybeModule (Module p) | p == nullPtr = Nothing
maybeModule f                         = Just (unsafeCoerce f)

unMaybeModule :: Maybe (Module s') -> Module s
unMaybeModule (Just f) = unsafeCoerce f
unMaybeModule Nothing  = Module nullPtr

%dis maybe_cxmodule m = <unMaybeModule/maybeModule> (cxmodule m)

-- CXModule clang_Cursor_getModule(CXCursor C);
%fun clang_Cursor_getModule :: Proxy s -> Cursor s' -> IO (Module s)
%call (proxy) (cursor k xdata p1 p2 p3)
%code CXCursor a = {k, xdata, {p1, p2, p3}};
%     CXModule r = clang_Cursor_getModule(a);
%result (cxmodule r)

-- CXFile clang_Module_getASTFile(CXModule Module);
%fun clang_Module_getASTFile :: Proxy s -> Module s' -> IO (File s)
%call (proxy) (cxmodule m)
%code CXFile r = clang_Module_getASTFile(m);
%result (file r)

-- CXModule clang_Module_getParent(CXModule Module);
%fun clang_Module_getParent :: Proxy s -> Module s' -> IO (Maybe (Module s))
%call (proxy) (cxmodule m)
%code CXModule r = clang_Module_getParent(m);
%result (maybe_cxmodule r)

-- CXString clang_Module_getName(CXModule Module);
%fun unsafe_Module_getName :: Module s -> IO (CXString ())
%call (cxmodule m)
%code CXString out = clang_Module_getName(m);
%     const void* outData = out.data;
%     unsigned outFlags = out.private_flags;
%result (cxString (ptr outData) (word32 outFlags))

module_getName :: ClangBase m => Module s' -> ClangT s m (CXString s)
module_getName = registerCXString . unsafe_Module_getName

-- CXString clang_Module_getFullName(CXModule Module);
%fun unsafe_Module_getFullName :: Module s -> IO (CXString ())
%call (cxmodule m)
%code CXString out = clang_Module_getFullName(m);
%     const void* outData = out.data;
%     unsigned outFlags = out.private_flags;
%result (cxString (ptr outData) (word32 outFlags))

module_getFullName :: ClangBase m => Module s' -> ClangT s m (CXString s)
module_getFullName = registerCXString . unsafe_Module_getFullName

-- unsigned clang_Module_getNumTopLevelHeaders(CXTranslationUnit, CXModule Module);
%fun clang_Module_getNumTopLevelHeaders :: TranslationUnit s -> Module s' -> IO Int
%call (translationUnit t) (cxmodule m)
%code unsigned r = clang_Module_getNumTopLevelHeaders(t, m);
%result (int r)

-- CXFile clang_Module_getTopLevelHeader(CXTranslationUnit, CXModule Module, unsigned Index);
%fun clang_Module_getTopLevelHeader :: Proxy s -> TranslationUnit s' -> Module s'' -> Int -> IO (File s)
%call (proxy) (translationUnit t) (cxmodule m) (int idx)
%code CXFile r = clang_Module_getTopLevelHeader(t, m, idx);
%result (file r)

-- unsigned clang_CXXMethod_isPureVirtual(CXCursor C);
%fun clang_CXXMethod_isPureVirtual :: Cursor s -> IO Bool
%call (cursor k xdata p1 p2 p3)
%code CXCursor a = {k, xdata, {p1, p2, p3}};
%     r = clang_CXXMethod_isPureVirtual(a);
%result (bool r)

-- unsigned clang_CXXMethod_isStatic(CXCursor C);
%fun clang_CXXMethod_isStatic :: Cursor s -> IO Bool
%call (cursor k xdata p1 p2 p3)
%code CXCursor a = {k, xdata, {p1, p2, p3}};
%     r = clang_CXXMethod_isStatic(a);
%result (bool r)

-- unsigned clang_CXXMethod_isVirtual(CXCursor C);
%fun clang_CXXMethod_isVirtual :: Cursor s -> IO Bool
%call (cursor k xdata p1 p2 p3)
%code CXCursor a = {k, xdata, {p1, p2, p3}};
%     r = clang_CXXMethod_isVirtual(a);
%result (bool r)

-- enum CXCursorKind clang_getTemplateCursorKind(CXCursor C);
%fun clang_getTemplateCursorKind :: Cursor s -> IO CursorKind
%call (cursor k xdata p1 p2 p3)
%code CXCursor a = {k, xdata, {p1, p2, p3}};
%     r = clang_getTemplateCursorKind(a);
%result (cursorKind r)

-- CXCursor clang_getSpecializedCursorTemplate(CXCursor C);
%fun clang_getSpecializedCursorTemplate :: Proxy s -> Cursor s' -> IO (Cursor s)
%call (proxy) (cursor k xdata p1 p2 p3)
%code CXCursor a = {k, xdata, {p1, p2, p3}};
%     CXCursor r = clang_getSpecializedCursorTemplate(a);
%result (cursor {r.kind} {r.xdata} {r.data[0]} {r.data[1]} {r.data[2]})

-- enum CXCommentKind {
--   CXComment_Null = 0,
--   CXComment_Text = 1,
--   CXComment_InlineCommand = 2,
--   CXComment_HTMLStartTag = 3,
--   CXComment_HTMLEndTag = 4,
--   CXComment_Paragraph = 5,
--   CXComment_BlockCommand = 6,
--   CXComment_ParamCommand = 7,
--   CXComment_TParamCommand = 8,
--   CXComment_VerbatimBlockCommand = 9,
--   CXComment_VerbatimBlockLine = 10,
--   CXComment_VerbatimLine = 11,
--   CXComment_FullComment = 12
-- };
%enum CommentKind (Bounded, Enum, Eq, Ord, Read, Show) Int [CXComment_Null, CXComment_Text, CXComment_InlineCommand, CXComment_HTMLStartTag, CXComment_HTMLEndTag, CXComment_Paragraph, CXComment_BlockCommand, CXComment_ParamCommand, CXComment_TParamCommand, CXComment_VerbatimBlockCommand, CXComment_VerbatimBlockLine, CXComment_VerbatimLine, CXComment_FullComment]

-- enum CXCommentInlineCommandRenderKind {
--   CXCommentInlineCommandRenderKind_Normal,
--   CXCommentInlineCommandRenderKind_Bold,
--   CXCommentInlineCommandRenderKind_Monospaced,
--   CXCommentInlineCommandRenderKind_Emphasized
-- };
%enum CommentInlineCommandRenderKind (Bounded, Enum, Eq, Ord, Read, Show) Int [CXCommentInlineCommandRenderKind_Normal, CXCommentInlineCommandRenderKind_Bold, CXCommentInlineCommandRenderKind_Monospaced, CXCommentInlineCommandRenderKind_Emphasized]

-- enum CXCommentParamPassDirection {
--   CXCommentParamPassDirection_In,
--   CXCommentParamPassDirection_Out,
--   CXCommentParamPassDirection_InOut
-- };
%enum CommentParamPassDirection (Bounded, Enum, Eq, Ord, Read, Show) Int [CXCommentParamPassDirection_In, CXCommentParamPassDirection_Out, CXCommentParamPassDirection_InOut]

-- enum CXCommentKind clang_Comment_getKind(CXComment Comment);
%fun clang_Comment_getKind :: Comment s -> IO CommentKind
%call (comment p1 p2)
%code CXComment a = {p1, p2};
%     enum CXCommentKind r = clang_Comment_getKind(a);
%result (commentKind r)

-- unsigned clang_Comment_getNumChildren(CXComment Comment);
%fun clang_Comment_getNumChildren :: Comment s -> IO Int
%call (comment p1 p2)
%code CXComment a = {p1, p2};
%     unsigned r = clang_Comment_getNumChildren(a);
%result (int r)

-- CXComment clang_Comment_getChild(CXComment Comment, unsigned ChildIdx);
%fun clang_Comment_getChild :: Proxy s -> Comment s' -> Int -> IO (Comment s)
%call (proxy) (comment p1 p2) (int idx)
%code CXComment a = {p1, p2};
%     CXComment r = clang_Comment_getChild(a, idx);
%result (comment {r.ASTNode} {r.TranslationUnit})

-- unsigned clang_Comment_isWhitespace(CXComment Comment);
%fun clang_Comment_isWhitespace :: Comment s -> IO Bool
%call (comment p1 p2)
%code CXComment a = {p1, p2};
%     unsigned r = clang_Comment_isWhitespace(a);
%result (bool r)

-- unsigned clang_InlineContentComment_hasTrailingNewline(CXComment Comment);
%fun clang_InlineContentComment_hasTrailingNewline :: Comment s -> IO Bool
%call (comment p1 p2)
%code CXComment a = {p1, p2};
%     unsigned r = clang_InlineContentComment_hasTrailingNewline(a);
%result (bool r)

-- CXString clang_TextComment_getText(CXComment Comment);
%fun unsafe_TextComment_getText :: Comment s -> IO (CXString ())
%call (comment p1 p2)
%code CXComment a = {p1, p2};
%     CXString out = clang_TextComment_getText(a);
%     const void* outData = out.data;
%     unsigned outFlags = out.private_flags;
%result (cxString (ptr outData) (word32 outFlags))

textComment_getText :: ClangBase m => Comment s' -> ClangT s m (CXString s)
textComment_getText = registerCXString . unsafe_TextComment_getText

-- CXString clang_InlineCommandComment_getCommandName(CXComment Comment);
%fun unsafe_InlineCommandComment_getCommandName :: Comment s -> IO (CXString ())
%call (comment p1 p2)
%code CXComment a = {p1, p2};
%     CXString out = clang_InlineCommandComment_getCommandName(a);
%     const void* outData = out.data;
%     unsigned outFlags = out.private_flags;
%result (cxString (ptr outData) (word32 outFlags))

inlineCommandComment_getCommandName :: ClangBase m => Comment s' -> ClangT s m (CXString s)
inlineCommandComment_getCommandName = registerCXString . unsafe_InlineCommandComment_getCommandName

-- enum CXCommentInlineCommandRenderKind clang_InlineCommandComment_getRenderKind(CXComment Comment);
%fun clang_InlineCommandComment_getRenderKind :: Comment s -> IO CommentInlineCommandRenderKind
%call (comment p1 p2)
%code CXComment a = {p1, p2};
%     enum CXCommentInlineCommandRenderKind r = clang_InlineCommandComment_getRenderKind(a);
%result (commentInlineCommandRenderKind r)

-- unsigned clang_InlineCommandComment_getNumArgs(CXComment Comment);
%fun clang_InlineCommandComment_getNumArgs :: Comment s -> IO Int
%call (comment p1 p2)
%code CXComment a = {p1, p2};
%     unsigned r = clang_InlineCommandComment_getNumArgs(a);
%result (int r)

-- CXString clang_InlineCommandComment_getArgText(CXComment Comment, unsigned ArgIdx);
%fun unsafe_InlineCommandComment_getArgText :: Comment s -> Int -> IO (CXString ())
%call (comment p1 p2) (int idx)
%code CXComment a = {p1, p2};
%     CXString out = clang_InlineCommandComment_getArgText(a, idx);
%     const void* outData = out.data;
%     unsigned outFlags = out.private_flags;
%result (cxString (ptr outData) (word32 outFlags))

inlineCommandComment_getArgText :: ClangBase m => Comment s' -> Int -> ClangT s m (CXString s)
inlineCommandComment_getArgText = (registerCXString .) . unsafe_InlineCommandComment_getArgText

-- CXString clang_HTMLTagComment_getTagName(CXComment Comment);
%fun unsafe_HTMLTagComment_getTagName :: Comment s -> IO (CXString ())
%call (comment p1 p2)
%code CXComment a = {p1, p2};
%     CXString out = clang_HTMLTagComment_getTagName(a);
%     const void* outData = out.data;
%     unsigned outFlags = out.private_flags;
%result (cxString (ptr outData) (word32 outFlags))

hTMLTagComment_getTagName :: ClangBase m => Comment s' -> ClangT s m (CXString s)
hTMLTagComment_getTagName = registerCXString . unsafe_HTMLTagComment_getTagName

-- unsigned clang_HTMLStartTagComment_isSelfClosing(CXComment Comment);
%fun clang_HTMLStartTagComment_isSelfClosing :: Comment s -> IO Bool
%call (comment p1 p2)
%code CXComment a = {p1, p2};
%     unsigned r = clang_HTMLStartTagComment_isSelfClosing(a);
%result (bool r)

-- unsigned clang_HTMLStartTag_getNumAttrs(CXComment Comment);
%fun clang_HTMLStartTag_getNumAttrs :: Comment s -> IO Int
%call (comment p1 p2)
%code CXComment a = {p1, p2};
%     unsigned r = clang_HTMLStartTag_getNumAttrs(a);
%result (int r)

-- CXString clang_HTMLStartTag_getAttrName(CXComment Comment, unsigned AttrIdx);
%fun unsafe_HTMLStartTag_getAttrName :: Comment s -> Int -> IO (CXString ())
%call (comment p1 p2) (int idx)
%code CXComment a = {p1, p2};
%     CXString out = clang_HTMLStartTag_getAttrName(a, idx);
%     const void* outData = out.data;
%     unsigned outFlags = out.private_flags;
%result (cxString (ptr outData) (word32 outFlags))

hTMLStartTag_getAttrName :: ClangBase m => Comment s' -> Int -> ClangT s m (CXString s)
hTMLStartTag_getAttrName = (registerCXString .) . unsafe_HTMLStartTag_getAttrName

-- CXString clang_HTMLStartTag_getAttrValue(CXComment Comment, unsigned AttrIdx);
%fun unsafe_HTMLStartTag_getAttrValue :: Comment s -> Int -> IO (CXString ())
%call (comment p1 p2) (int idx)
%code CXComment a = {p1, p2};
%     CXString out = clang_HTMLStartTag_getAttrValue(a, idx);
%     const void* outData = out.data;
%     unsigned outFlags = out.private_flags;
%result (cxString (ptr outData) (word32 outFlags))

hTMLStartTag_getAttrValue :: ClangBase m => Comment s' -> Int -> ClangT s m (CXString s)
hTMLStartTag_getAttrValue = (registerCXString .) . unsafe_HTMLStartTag_getAttrValue

-- CXString clang_BlockCommandComment_getCommandName(CXComment Comment);
%fun unsafe_BlockCommandComment_getCommandName :: Comment s -> IO (CXString ())
%call (comment p1 p2)
%code CXComment a = {p1, p2};
%     CXString out = clang_BlockCommandComment_getCommandName(a);
%     const void* outData = out.data;
%     unsigned outFlags = out.private_flags;
%result (cxString (ptr outData) (word32 outFlags))

blockCommandComment_getCommandName :: ClangBase m => Comment s' -> ClangT s m (CXString s)
blockCommandComment_getCommandName = registerCXString . unsafe_BlockCommandComment_getCommandName

-- unsigned clang_BlockCommandComment_getNumArgs(CXComment Comment);
%fun clang_BlockCommandComment_getNumArgs :: Comment s -> IO Int
%call (comment p1 p2)
%code CXComment a = {p1, p2};
%     unsigned r = clang_BlockCommandComment_getNumArgs(a);
%result (int r)

-- CXString clang_BlockCommandComment_getArgText(CXComment Comment, unsigned ArgIdx);
%fun unsafe_BlockCommandComment_getArgText :: Comment s -> Int -> IO (CXString ())
%call (comment p1 p2) (int idx)
%code CXComment a = {p1, p2};
%     CXString out = clang_BlockCommandComment_getArgText(a, idx);
%     const void* outData = out.data;
%     unsigned outFlags = out.private_flags;
%result (cxString (ptr outData) (word32 outFlags))

blockCommandComment_getArgText :: ClangBase m => Comment s' -> Int -> ClangT s m (CXString s)
blockCommandComment_getArgText = (registerCXString .) . unsafe_BlockCommandComment_getArgText

-- CXComment clang_BlockCommandComment_getParagraph(CXComment Comment);
%fun clang_BlockCommandComment_getParagraph :: Proxy s -> Comment s' -> IO (Comment s)
%call (proxy) (comment p1 p2)
%code CXComment a = {p1, p2};
%     CXComment r = clang_BlockCommandComment_getParagraph(a);
%result (comment {r.ASTNode} {r.TranslationUnit})

-- CXString clang_ParamCommandComment_getParamName(CXComment Comment);
%fun unsafe_ParamCommandComment_getParamName :: Comment s -> IO (CXString ())
%call (comment p1 p2)
%code CXComment a = {p1, p2};
%     CXString out = clang_ParamCommandComment_getParamName(a);
%     const void* outData = out.data;
%     unsigned outFlags = out.private_flags;
%result (cxString (ptr outData) (word32 outFlags))

paramCommandComment_getParamName :: ClangBase m => Comment s' -> ClangT s m (CXString s)
paramCommandComment_getParamName = registerCXString . unsafe_ParamCommandComment_getParamName

-- unsigned clang_ParamCommandComment_isParamIndexValid(CXComment Comment);
%fun clang_ParamCommandComment_isParamIndexValid :: Comment s -> IO Bool
%call (comment p1 p2)
%code CXComment a = {p1, p2};
%     unsigned r = clang_ParamCommandComment_isParamIndexValid(a);
%result (bool r)

-- unsigned clang_ParamCommandComment_getParamIndex(CXComment Comment);
%fun clang_ParamCommandComment_getParamIndex :: Comment s -> IO Int
%call (comment p1 p2)
%code CXComment a = {p1, p2};
%     unsigned r = clang_ParamCommandComment_getParamIndex(a);
%result (int r)

-- unsigned clang_ParamCommandComment_isDirectionExplicit(CXComment Comment);
%fun clang_ParamCommandComment_isDirectionExplicit :: Comment s -> IO Bool
%call (comment p1 p2)
%code CXComment a = {p1, p2};
%     unsigned r = clang_ParamCommandComment_isDirectionExplicit(a);
%result (bool r)

-- enum CXCommentParamPassDirection clang_ParamCommandComment_getDirection(CXComment Comment);
%fun clang_ParamCommandComment_getDirection :: Comment s -> IO CommentParamPassDirection
%call (comment p1 p2)
%code CXComment a = {p1, p2};
%     enum CXCommentParamPassDirection r = clang_ParamCommandComment_getDirection(a);
%result (commentParamPassDirection r)

-- CXString clang_TParamCommandComment_getParamName(CXComment Comment);
%fun unsafe_TParamCommandComment_getParamName :: Comment s -> IO (CXString ())
%call (comment p1 p2)
%code CXComment a = {p1, p2};
%     CXString out = clang_TParamCommandComment_getParamName(a);
%     const void* outData = out.data;
%     unsigned outFlags = out.private_flags;
%result (cxString (ptr outData) (word32 outFlags))

tParamCommandComment_getParamName :: ClangBase m => Comment s' -> ClangT s m (CXString s)
tParamCommandComment_getParamName = registerCXString . unsafe_TParamCommandComment_getParamName

-- unsigned clang_TParamCommandComment_isParamPositionValid(CXComment Comment);
%fun clang_TParamCommandComment_isParamPositionValid :: Comment s -> IO Bool
%call (comment p1 p2)
%code CXComment a = {p1, p2};
%     unsigned r = clang_TParamCommandComment_isParamPositionValid(a);
%result (bool r)

-- unsigned clang_TParamCommandComment_getDepth(CXComment Comment);
%fun clang_TParamCommandComment_getDepth :: Comment s -> IO Int
%call (comment p1 p2)
%code CXComment a = {p1, p2};
%     unsigned r = clang_TParamCommandComment_getDepth(a);
%result (int r)

-- unsigned clang_TParamCommandComment_getIndex(CXComment Comment, unsigned Depth);
%fun clang_TParamCommandComment_getIndex :: Comment s -> Int -> IO Int
%call (comment p1 p2) (int depth)
%code CXComment a = {p1, p2};
%     unsigned r = clang_TParamCommandComment_getIndex(a, depth);
%result (int r)

-- CXString clang_VerbatimBlockLineComment_getText(CXComment Comment);
%fun unsafe_VerbatimBlockLineComment_getText :: Comment s -> IO (CXString ())
%call (comment p1 p2)
%code CXComment a = {p1, p2};
%     CXString out = clang_VerbatimBlockLineComment_getText(a);
%     const void* outData = out.data;
%     unsigned outFlags = out.private_flags;
%result (cxString (ptr outData) (word32 outFlags))

verbatimBlockLineComment_getText :: ClangBase m => Comment s' -> ClangT s m (CXString s)
verbatimBlockLineComment_getText = registerCXString . unsafe_VerbatimBlockLineComment_getText

-- CXString clang_VerbatimLineComment_getText(CXComment Comment);
%fun unsafe_VerbatimLineComment_getText :: Comment s -> IO (CXString ())
%call (comment p1 p2)
%code CXComment a = {p1, p2};
%     CXString out = clang_VerbatimLineComment_getText(a);
%     const void* outData = out.data;
%     unsigned outFlags = out.private_flags;
%result (cxString (ptr outData) (word32 outFlags))

verbatimLineComment_getText :: ClangBase m => Comment s' -> ClangT s m (CXString s)
verbatimLineComment_getText = registerCXString . unsafe_VerbatimLineComment_getText

-- CXString clang_HTMLTagComment_getAsString(CXComment Comment);
%fun unsafe_HTMLTagComment_getAsString :: Comment s -> IO (CXString ())
%call (comment p1 p2)
%code CXComment a = {p1, p2};
%     CXString out = clang_HTMLTagComment_getAsString(a);
%     const void* outData = out.data;
%     unsigned outFlags = out.private_flags;
%result (cxString (ptr outData) (word32 outFlags))

hTMLTagComment_getAsString :: ClangBase m => Comment s' -> ClangT s m (CXString s)
hTMLTagComment_getAsString = registerCXString . unsafe_HTMLTagComment_getAsString

-- CXString clang_FullComment_getAsHTML(CXComment Comment);
%fun unsafe_FullComment_getAsHTML :: Comment s -> IO (CXString ())
%call (comment p1 p2)
%code CXComment a = {p1, p2};
%     CXString out = clang_FullComment_getAsHTML(a);
%     const void* outData = out.data;
%     unsigned outFlags = out.private_flags;
%result (cxString (ptr outData) (word32 outFlags))

fullComment_getAsHTML :: ClangBase m => Comment s' -> ClangT s m (CXString s)
fullComment_getAsHTML = registerCXString . unsafe_FullComment_getAsHTML

-- CXString clang_FullComment_getAsXML(CXComment Comment);
%fun unsafe_FullComment_getAsXML :: Comment s -> IO (CXString ())
%call (comment p1 p2)
%code CXComment a = {p1, p2};
%     CXString out = clang_FullComment_getAsXML(a);
%     const void* outData = out.data;
%     unsigned outFlags = out.private_flags;
%result (cxString (ptr outData) (word32 outFlags))

fullComment_getAsXML :: ClangBase m => Comment s' -> ClangT s m (CXString s)
fullComment_getAsXML = registerCXString . unsafe_FullComment_getAsXML

-- typedef enum CXTokenKind {
--   CXToken_Punctuation,
--   CXToken_Keyword,
--   CXToken_Identifier,
--   CXToken_Literal,
--   CXToken_Comment
-- } CXTokenKind;
%enum TokenKind (Bounded, Enum, Eq, Ord, Read, Show) Int [CXToken_Punctuation, CXToken_Keyword, CXToken_Identifier, CXToken_Literal, CXToken_Comment]

-- typedef struct {
--   unsigned int_data[4];
--   void *ptr_data;
-- } CXToken;
data Token s = Token !Int !Int !Int !Int !(Ptr ())
%dis token w x y z p = Token (int w) (int x) (int y) (int z) (ptr p)

instance Storable (Token s) where
    sizeOf _ = sizeOfCXToken
    {-# INLINE sizeOf #-}

    alignment _ = alignOfCXToken
    {-# INLINE alignment #-}

    peek p = do
      i1 <- peekByteOff p offsetCXTokenI1
      i2 <- peekByteOff p offsetCXTokenI2
      i3 <- peekByteOff p offsetCXTokenI3
      i4 <- peekByteOff p offsetCXTokenI4
      d <- peekByteOff p offsetCXTokenData
      return $! Token i1 i2 i3 i4 d
    {-# INLINE peek #-}

    poke p (Token i1 i2 i3 i4 d) = do
      pokeByteOff p offsetCXTokenI1 i1
      pokeByteOff p offsetCXTokenI2 i2
      pokeByteOff p offsetCXTokenI3 i3
      pokeByteOff p offsetCXTokenI4 i4
      pokeByteOff p offsetCXTokenData d
    {-# INLINE poke #-}

-- CXTokenKind clang_getTokenKind(CXToken);
%fun clang_getTokenKind :: Token s -> IO TokenKind
%call (token w x y z p)
%code CXToken a = {{w, x, y, z}, p};
%     r = clang_getTokenKind(a);
%result (tokenKind r)

-- CXString clang_getTokenSpelling(CXTranslationUnit, CXToken);
%fun unsafe_getTokenSpelling :: TranslationUnit s -> Token s' -> IO (CXString ())
%call (translationUnit t) (token w x y z p)
%code CXToken a = {{w, x, y, z}, p};
%     CXString out = clang_getTokenSpelling(t, a);
%     const void* outData = out.data;
%     unsigned outFlags = out.private_flags;
%result (cxString (ptr outData) (word32 outFlags))

getTokenSpelling :: ClangBase m => TranslationUnit s' -> Token s'' -> ClangT s m (CXString s)
getTokenSpelling = (registerCXString .) . unsafe_getTokenSpelling

-- CXSourceLocation clang_getTokenLocation(CXTranslationUnit,
--                                                        CXToken);
%fun clang_getTokenLocation :: Proxy s -> TranslationUnit s' -> Token s'' -> IO (SourceLocation s)
%call (proxy) (translationUnit t) (token w x y z p)
%code CXToken a = {{w, x, y, z}, p};
%     CXSourceLocation r = clang_getTokenLocation(t, a);
%result (sourceLocation {r.ptr_data[0]} {r.ptr_data[1]} {r.int_data})

-- CXSourceRange clang_getTokenExtent(CXTranslationUnit, CXToken);
%fun clang_getTokenExtent :: Proxy s -> TranslationUnit s' -> Token s'' -> IO (SourceRange s)
%call (proxy) (translationUnit t) (token w x y z p)
%code CXToken a = {{w, x, y, z}, p};
%     CXSourceRange r = clang_getTokenExtent(t, a);
%result (sourceRange {r.ptr_data[0]} {r.ptr_data[1]} {r.begin_int_data} {r.end_int_data})

-- We deliberately don't export the constructor. The only way to unwrap this is registerCursorList.
type TokenList s = DVS.Vector (Token s)
data UnsafeTokenList = UnsafeTokenList !(Ptr ()) !Int

foreign import ccall unsafe "FFI_stub_ffi.h clang_disposeTokens" clang_disposeTokens :: Ptr () -> Ptr () -> CUInt -> IO ()

-- void clang_disposeTokens(CXTranslationUnit TU, CXToken *Tokens, unsigned NumTokens);
%fun clang_disposeTokens :: TranslationUnit s -> TokenList s' -> IO ()
%call (translationUnit t) (tokenList toks n)
%code clang_disposeTokens(t, toks, n);

registerTokenList :: ClangBase m => TranslationUnit s' -> IO UnsafeTokenList
                  -> ClangT s m (TokenList s)
registerTokenList tu action = do
    (_, tokenList) <- clangAllocate (action >>= tokenListToVector) (disposeTokens tu)
    return tokenList
{-# INLINEABLE registerTokenList #-}

tokenListToVector :: Storable a => UnsafeTokenList -> IO (DVS.Vector a)
tokenListToVector (UnsafeTokenList ts n) = do
  fptr <- newForeignPtr_ (castPtr ts)
  return $ DVS.unsafeFromForeignPtr fptr 0 n
{-# INLINE tokenListToVector #-}

fromTokenList :: TokenList s -> (Ptr (), Int)
fromTokenList ts = let (p, _, _) = DVS.unsafeToForeignPtr ts in
                   (castPtr $ Foreign.ForeignPtr.Unsafe.unsafeForeignPtrToPtr p, DVS.length ts)

toTokenList :: (Ptr (), Int) -> UnsafeTokenList
toTokenList (ts, n) = UnsafeTokenList ts n

%dis tokenList ts n = <fromTokenList/toTokenList> (ptr ts) (int n)

-- void clang_tokenize(CXTranslationUnit TU, CXSourceRange Range,
--                                    CXToken **Tokens, unsigned *NumTokens);
%fun unsafe_tokenize :: TranslationUnit s -> SourceRange s' -> IO UnsafeTokenList
%call (translationUnit t) (sourceRange p1 p2 d1 d2)
%code CXSourceRange a = {{p1, p2}, d1, d2};
%     CXToken* tokens; unsigned numTokens;
%     clang_tokenize(t, a, &tokens, &numTokens);
%result (tokenList tokens numTokens)

tokenize :: ClangBase m => TranslationUnit s' -> SourceRange s'' -> ClangT s m (TokenList s)
tokenize tu = registerTokenList tu . unsafe_tokenize tu

-- TODO: test me
-- Note that registerCursorList can be used for the result of this
-- function because it just calls free() to dispose of the list.
--
-- void clang_annotateTokens(CXTranslationUnit TU,
--                                          CXToken *Tokens, unsigned NumTokens,
--                                          CXCursor *Cursors);
%fun unsafe_annotateTokens :: TranslationUnit s -> TokenList s' -> IO UnsafeCursorList
%call (translationUnit t) (tokenList toks nts)
%code CXCursor * cs = (CXCursor *)malloc(sizeof(CXCursor)*nts);
%     unsigned count = nts;
%     clang_annotateTokens(t, toks, nts, cs);
%result (cursorList cs count)

annotateTokens :: ClangBase m => TranslationUnit s' -> TokenList s'' -> ClangT s m (CursorList s)
annotateTokens = (registerCursorList .) . unsafe_annotateTokens

-- CXString clang_getCursorKindSpelling(enum CXCursorKind Kind);
%fun unsafe_getCursorKindSpelling :: CursorKind -> IO (CXString ())
%call (cursorKind k)
%code CXString out = clang_getCursorKindSpelling(k);
%     const void* outData = out.data;
%     unsigned outFlags = out.private_flags;
%result (cxString (ptr outData) (word32 outFlags))

getCursorKindSpelling :: ClangBase m => CursorKind -> ClangT s m (CXString s)
getCursorKindSpelling = registerCXString . unsafe_getCursorKindSpelling

-- void clang_enableStackTraces(void);
foreign import ccall unsafe "clang-c/Index.h clang_enableStackTraces" enableStackTraces :: IO ()

-- TODO: implement me after figuring out what this function really does
-- void clang_executeOnThread(void (*fn)(void*), void *user_data,
--                                           unsigned stack_size);

-- typedef void *CXCompletionString;
newtype CompletionString s = CompletionString (Ptr ())
%dis completionString x = CompletionString (ptr x)

-- typedef struct {
--   enum CXCursorKind CursorKind;
--   CXCompletionString CompletionString;
-- } CXCompletionResult;
data CompletionResult s = CompletionResult !CursorKind !(CompletionString s)
%dis completionResult k s = CompletionResult (cursorKind k) (competionString s)

-- enum CXCompletionChunkKind {
--   CXCompletionChunk_Optional,
--   CXCompletionChunk_TypedText,
--   CXCompletionChunk_Text,
--   CXCompletionChunk_Placeholder,
--   CXCompletionChunk_Informative,
--   CXCompletionChunk_CurrentParameter,
--   CXCompletionChunk_LeftParen,
--   CXCompletionChunk_RightParen,
--   CXCompletionChunk_LeftBracket,
--   CXCompletionChunk_RightBracket,
--   CXCompletionChunk_LeftBrace,
--   CXCompletionChunk_RightBrace,
--   CXCompletionChunk_LeftAngle,
--   CXCompletionChunk_RightAngle,
--   CXCompletionChunk_Comma,
--   CXCompletionChunk_ResultType,
--   CXCompletionChunk_Colon,
--   CXCompletionChunk_SemiColon,
--   CXCompletionChunk_Equal,
--   CXCompletionChunk_HorizontalSpace,
--   CXCompletionChunk_VerticalSpace
-- };
%enum CompletionChunkKind (Bounded, Enum, Eq, Ord, Read, Show) Int [CXCompletionChunk_Optional,CXCompletionChunk_TypedText,CXCompletionChunk_Text,CXCompletionChunk_Placeholder,CXCompletionChunk_Informative,CXCompletionChunk_CurrentParameter,CXCompletionChunk_LeftParen,CXCompletionChunk_RightParen,CXCompletionChunk_LeftBracket,CXCompletionChunk_RightBracket,CXCompletionChunk_LeftBrace,CXCompletionChunk_RightBrace,CXCompletionChunk_LeftAngle,CXCompletionChunk_RightAngle,CXCompletionChunk_Comma,CXCompletionChunk_ResultType,CXCompletionChunk_Colon,CXCompletionChunk_SemiColon,CXCompletionChunk_Equal,CXCompletionChunk_HorizontalSpace,CXCompletionChunk_VerticalSpace]

-- enum CXCompletionChunkKind
-- clang_getCompletionChunkKind(CXCompletionString completion_string,
--                              unsigned chunk_number);
%fun clang_getCompletionChunkKind :: CompletionString s -> Int -> IO CompletionChunkKind

-- CXString
-- clang_getCompletionChunkText(CXCompletionString completion_string,
--                              unsigned chunk_number);
%fun unsafe_getCompletionChunkText :: CompletionString s -> Int -> IO (CXString ())
%call (completionString s) (int i)
%code CXString out = clang_getCompletionChunkText(s, i);
%     const void* outData = out.data;
%     unsigned outFlags = out.private_flags;
%result (cxString (ptr outData) (word32 outFlags))

getCompletionChunkText :: ClangBase m => CompletionString s' -> Int -> ClangT s m (CXString s)
getCompletionChunkText = (registerCXString .) . unsafe_getCompletionChunkText

-- CXCompletionString
-- clang_getCompletionChunkCompletionString(CXCompletionString completion_string,
--                                          unsigned chunk_number);
%fun clang_getCompletionChunkCompletionString :: CompletionString s' -> Int -> IO (CompletionString s)

-- unsigned
-- clang_getNumCompletionChunks(CXCompletionString completion_string);
%fun clang_getNumCompletionChunks :: CompletionString s -> IO Int

-- unsigned
-- clang_getCompletionPriority(CXCompletionString completion_string);
%fun clang_getCompletionPriority :: CompletionString s -> IO Int
  
-- enum CXAvailabilityKind 
-- clang_getCompletionAvailability(CXCompletionString completion_string);
%fun clang_getCompletionAvailability :: CompletionString s -> IO AvailabilityKind

-- unsigned clang_getCompletionNumAnnotations(CXCompletionString completion_string);
%fun clang_getCompletionNumAnnotations :: CompletionString s -> IO Int

-- CXString clang_getCompletionAnnotation(CXCompletionString completion_string,
--                                        unsigned annotation_number);
%fun unsafe_getCompletionAnnotation :: CompletionString s -> Int -> IO (CXString ())
%call (completionString s) (int i)
%code CXString out = clang_getCompletionAnnotation(s, i);
%     const void* outData = out.data;
%     unsigned outFlags = out.private_flags;
%result (cxString (ptr outData) (word32 outFlags))

getCompletionAnnotation :: ClangBase m => CompletionString s' -> Int -> ClangT s m (CXString s)
getCompletionAnnotation = (registerCXString .) . unsafe_getCompletionAnnotation

-- CXString clang_getCompletionParent(CXCompletionString completion_string,
--                                    enum CXCursorKind *kind);
%fun unsafe_getCompletionParent :: CompletionString s -> IO (CXString ())
%call (completionString s)
%code CXString out = clang_getCompletionParent(s, NULL);
%     const void* outData = out.data;
%     unsigned outFlags = out.private_flags;
%result (cxString (ptr outData) (word32 outFlags))

getCompletionParent :: ClangBase m => CompletionString s' -> ClangT s m (CXString s)
getCompletionParent = registerCXString . unsafe_getCompletionParent

-- CXString clang_getCompletionBriefComment(CXCompletionString completion_string);
%fun unsafe_getCompletionBriefComment :: CompletionString s -> IO (CXString ())
%call (completionString s)
%code CXString out = clang_getCompletionBriefComment(s);
%     const void* outData = out.data;
%     unsigned outFlags = out.private_flags;
%result (cxString (ptr outData) (word32 outFlags))

getCompletionBriefComment :: ClangBase m => CompletionString s' -> ClangT s m (CXString s)
getCompletionBriefComment = registerCXString . unsafe_getCompletionBriefComment

-- CXCompletionString clang_getCursorCompletionString(CXCursor cursor);
%fun clang_getCursorCompletionString :: Cursor s' -> IO (CompletionString s)
%call (cursor k xdata p1 p2 p3)
%code CXCursor a = {k, xdata, {p1, p2, p3}};
%result (completionString {clang_getCursorCompletionString(a)})

-- enum CXCodeComplete_Flags {
--   CXCodeComplete_IncludeMacros = 0x01,
--   CXCodeComplete_IncludeCodePatterns = 0x02,
--   CXCodeComplete_IncludeBriefComments = 0x04
-- };
%enum CodeCompleteFlags (Bounded, Enum, Eq, Ord, Read, Show) Int [CXCodeComplete_IncludeMacros, CXCodeComplete_IncludeCodePatterns, CXCodeComplete_IncludeBriefComments]

instance BitFlags CodeCompleteFlags where
  toBit CodeComplete_IncludeMacros        = 0x01
  toBit CodeComplete_IncludeCodePatterns  = 0x02
  toBit CodeComplete_IncludeBriefComments = 0x04

-- unsigned clang_defaultCodeCompleteOptions(void);
%fun clang_defaultCodeCompleteOptions :: IO Int

-- typedef struct {
--   CXCompletionResult *Results;
--   unsigned NumResults;
-- } CXCodeCompleteResults;
newtype CodeCompleteResults s = CodeCompleteResults (Ptr ())

unCodeCompleteResults :: CodeCompleteResults s -> Ptr ()
unCodeCompleteResults (CodeCompleteResults p) = p

-- void clang_disposeCodeCompleteResults(CXCodeCompleteResults *Results);
%fun clang_disposeCodeCompleteResults :: CodeCompleteResults s -> IO ()
%call (codeCompleteResults rs)
%code clang_disposeCodeCompleteResults(rs);

registerCodeCompleteResults :: ClangBase m => IO (CodeCompleteResults ())
                            -> ClangT s m (CodeCompleteResults s)
registerCodeCompleteResults action = do
  (_, ccrs) <- clangAllocate (action >>= return . unsafeCoerce)
                             (\rs -> disposeCodeCompleteResults rs)
  return ccrs
{-# INLINEABLE registerCodeCompleteResults #-}

%dis codeCompleteResults rs = <unCodeCompleteResults/CodeCompleteResults> (ptr rs)

-- CXCodeCompleteResults *clang_codeCompleteAt(CXTranslationUnit TU,
--                                             const char *complete_filename,
--                                             unsigned complete_line,
--                                             unsigned complete_column,
--                                             struct CXUnsavedFile *unsaved_files,
--                                             unsigned num_unsaved_files,
--                                             unsigned options);
%fun unsafe_codeCompleteAt :: TranslationUnit s -> String -> Int -> Int -> Ptr CUnsavedFile -> Int -> Int -> IO (CodeCompleteResults ())
%call (translationUnit t) (string s) (int i1) (int i2) (ptr ufs) (int nufs) (int i3)
%code rs = clang_codeCompleteAt(t, s, i1, i2, ufs, nufs, i3)
%result (codeCompleteResults rs)

codeCompleteAt :: ClangBase m => TranslationUnit s' -> String -> Int -> Int
               -> DV.Vector UnsavedFile -> Int -> ClangT s m (CodeCompleteResults s)
codeCompleteAt tu f l c ufs os =
  registerCodeCompleteResults $
    withUnsavedFiles ufs $ \ufsPtr ufsLen ->
      unsafe_codeCompleteAt tu f l c ufsPtr ufsLen os

-- void clang_sortCodeCompletionResults(CXCompletionResult *Results,
--                                      unsigned NumResults);
%fun clang_sortCodeCompletionResults :: CodeCompleteResults s -> Int -> IO ()
%call (codeCompleteResults rs) (int i)
%code clang_sortCodeCompletionResults(rs, i);

-- unsigned clang_codeCompleteGetNumDiagnostics(CXCodeCompleteResults *Results);
%fun clang_codeCompleteGetNumDiagnostics :: CodeCompleteResults s -> IO Int
%call (codeCompleteResults rs)
%code nd = clang_codeCompleteGetNumDiagnostics(rs);
%result (int nd)

-- CXDiagnostic clang_codeCompleteGetDiagnostic(CXCodeCompleteResults *Results,
--                                              unsigned Index);
%fun unsafe_codeCompleteGetDiagnostic :: CodeCompleteResults s -> Int -> IO (Diagnostic ())
%call (codeCompleteResults rs) (int i)
%code CXDiagnostic r = clang_codeCompleteGetDiagnostic(rs, i);
%result (diag r)

codeCompleteGetDiagnostic :: ClangBase m => CodeCompleteResults s' -> Int
                          -> ClangT s m (Diagnostic s)
codeCompleteGetDiagnostic = (registerDiagnostic .) . unsafe_codeCompleteGetDiagnostic

-- enum CXCompletionContext {
--   CXCompletionContext_Unexposed = 0,
--   CXCompletionContext_AnyType = 1 << 0,
--   CXCompletionContext_AnyValue = 1 << 1,
--   CXCompletionContext_ObjCObjectValue = 1 << 2,
--   CXCompletionContext_ObjCSelectorValue = 1 << 3,
--   CXCompletionContext_CXXClassTypeValue = 1 << 4,
--   CXCompletionContext_DotMemberAccess = 1 << 5,
--   CXCompletionContext_ArrowMemberAccess = 1 << 6,
--   CXCompletionContext_ObjCPropertyAccess = 1 << 7,
--   CXCompletionContext_EnumTag = 1 << 8,
--   CXCompletionContext_UnionTag = 1 << 9,
--   CXCompletionContext_StructTag = 1 << 10,
--   CXCompletionContext_ClassTag = 1 << 11,
--   CXCompletionContext_Namespace = 1 << 12,
--   CXCompletionContext_NestedNameSpecifier = 1 << 13,
--   CXCompletionContext_ObjCInterface = 1 << 14,
--   CXCompletionContext_ObjCProtocol = 1 << 15,
--   CXCompletionContext_ObjCCategory = 1 << 16,
--   CXCompletionContext_ObjCInstanceMessage = 1 << 17,
--   CXCompletionContext_ObjCClassMessage = 1 << 18,
--   CXCompletionContext_ObjCSelectorName = 1 << 19,
--   CXCompletionContext_MacroName = 1 << 20,
--   CXCompletionContext_NaturalLanguage = 1 << 21,
--   CXCompletionContext_Unknown = ((1 << 22) - 1) -- Set all
                            --   contexts... Not a real value.
-- };
%enum CompletionContext (Bounded, Enum, Eq, Ord, Read, Show) Int64 [CXCompletionContext_Unexposed, CXCompletionContext_AnyType, CXCompletionContext_AnyValue, CXCompletionContext_ObjCObjectValue, CXCompletionContext_ObjCSelectorValue, CXCompletionContext_CXXClassTypeValue, CXCompletionContext_DotMemberAccess, CXCompletionContext_ArrowMemberAccess, CXCompletionContext_ObjCPropertyAccess, CXCompletionContext_EnumTag, CXCompletionContext_UnionTag, CXCompletionContext_StructTag, CXCompletionContext_ClassTag, CXCompletionContext_Namespace, CXCompletionContext_NestedNameSpecifier, CXCompletionContext_ObjCInterface, CXCompletionContext_ObjCProtocol, CXCompletionContext_ObjCCategory, CXCompletionContext_ObjCInstanceMessage, CXCompletionContext_ObjCClassMessage, CXCompletionContext_ObjCSelectorName, CXCompletionContext_MacroName, CXCompletionContext_NaturalLanguage]

instance BitFlags CompletionContext where
  type FlagInt CompletionContext              = Int64
  toBit CompletionContext_Unexposed           = 0x0
  toBit CompletionContext_AnyType             = 0x1
  toBit CompletionContext_AnyValue            = 0x2
  toBit CompletionContext_ObjCObjectValue     = 0x4
  toBit CompletionContext_ObjCSelectorValue   = 0x8
  toBit CompletionContext_CXXClassTypeValue   = 0x10
  toBit CompletionContext_DotMemberAccess     = 0x20
  toBit CompletionContext_ArrowMemberAccess   = 0x40
  toBit CompletionContext_ObjCPropertyAccess  = 0x80
  toBit CompletionContext_EnumTag             = 0x100
  toBit CompletionContext_UnionTag            = 0x200
  toBit CompletionContext_StructTag           = 0x400
  toBit CompletionContext_ClassTag            = 0x800
  toBit CompletionContext_Namespace           = 0x1000
  toBit CompletionContext_NestedNameSpecifier = 0x2000
  toBit CompletionContext_ObjCInterface       = 0x4000
  toBit CompletionContext_ObjCProtocol        = 0x8000
  toBit CompletionContext_ObjCCategory        = 0x10000
  toBit CompletionContext_ObjCInstanceMessage = 0x20000
  toBit CompletionContext_ObjCClassMessage    = 0x40000
  toBit CompletionContext_ObjCSelectorName    = 0x80000
  toBit CompletionContext_MacroName           = 0x100000
  toBit CompletionContext_NaturalLanguage     = 0x200000

-- unsigned long long clang_codeCompleteGetContexts(CXCodeCompleteResults *Results);
%fun clang_codeCompleteGetContexts :: CodeCompleteResults s -> IO Int64
%call (codeCompleteResults rs)
%code long long r = clang_codeCompleteGetContexts(rs);
%result (int64 r)

-- enum CXCursorKind clang_codeCompleteGetContainerKind(CXCodeCompleteResults *Results,
--                                                      unsigned *IsIncomplete);
%fun clang_codeCompleteGetContainerKind :: CodeCompleteResults s -> IO (CursorKind, Bool)
%call (codeCompleteResults rs)
%code unsigned isIncomplete;
%     enum CXCursorKind k = clang_codeCompleteGetContainerKind(rs, &isIncomplete);
%result (cursorKind k, bool isIncomplete)

-- CXString clang_codeCompleteGetContainerUSR(CXCodeCompleteResults *Results);
%fun unsafe_codeCompleteGetContainerUSR :: CodeCompleteResults s -> IO (CXString ())
%call (codeCompleteResults rs)
%code CXString out = clang_codeCompleteGetContainerUSR(rs);
%     const void* outData = out.data;
%     unsigned outFlags = out.private_flags;
%result (cxString (ptr outData) (word32 outFlags))

codeCompleteGetContainerUSR :: ClangBase m => CodeCompleteResults s' -> ClangT s m (CXString s)
codeCompleteGetContainerUSR = registerCXString . unsafe_codeCompleteGetContainerUSR

-- CXString clang_codeCompleteGetObjCSelector(CXCodeCompleteResults *Results);
%fun unsafe_codeCompleteGetObjCSelector :: CodeCompleteResults s -> IO (CXString ())
%call (codeCompleteResults rs)
%code CXString out = clang_codeCompleteGetObjCSelector(rs);
%     const void* outData = out.data;
%     unsigned outFlags = out.private_flags;
%result (cxString (ptr outData) (word32 outFlags))

codeCompleteGetObjCSelector :: ClangBase m => CodeCompleteResults s' -> ClangT s m (CXString s)
codeCompleteGetObjCSelector = registerCXString . unsafe_codeCompleteGetObjCSelector

-- CXString clang_getClangVersion();
%fun unsafe_getClangVersion :: IO (CXString ())
%code CXString out = clang_getClangVersion();
%     const void* outData = out.data;
%     unsigned outFlags = out.private_flags;
%result (cxString (ptr outData) (word32 outFlags))

getClangVersion :: ClangBase m => ClangT s m (CXString s)
getClangVersion = registerCXString $ unsafe_getClangVersion
  
-- -- void clang_toggleCrashRecovery(unsigned isEnabled);
%fun clang_toggleCrashRecovery :: Bool -> IO ()

data Inclusion s = Inclusion !(File s) !(SourceLocation s) !Bool

instance Storable (Inclusion s) where
    sizeOf _ = sizeOfInclusion
    {-# INLINE sizeOf #-}

    alignment _ = alignOfInclusion
    {-# INLINE alignment #-}

    peek p = do
      let fromCUChar = fromIntegral :: Num b => CUChar -> b
      file <- File <$> peekByteOff p offsetInclusionInclusion
      sl <- peekByteOff p offsetInclusionLocation
      isDirect <- fromCUChar <$> peekByteOff p offsetInclusionIsDirect
      return $! Inclusion file sl (if isDirect == 0 then False else True)
    {-# INLINE peek #-}

    poke p (Inclusion (File file) sl isDirect) = do
      let toCUChar = fromIntegral :: Integral a => a -> CUChar
      pokeByteOff p offsetInclusionInclusion file
      pokeByteOff p offsetInclusionLocation sl
      pokeByteOff p offsetInclusionIsDirect
           (toCUChar $ if isDirect then 1 else 0)
    {-# INLINE poke #-}

type InclusionList s = DVS.Vector (Inclusion s)
data UnsafeInclusionList = UnsafeInclusionList !(Ptr ()) !Int

-- void freeInclusions(struct Inclusion* inclusions);
%fun freeInclusions :: InclusionList s -> IO ()
%call (inclusionList is n)
%code freeInclusionList(is);

registerInclusionList :: ClangBase m => IO UnsafeInclusionList -> ClangT s m (InclusionList s)
registerInclusionList action = do
    (_, inclusionList) <- clangAllocate (action >>= mkSafe) freeInclusions
    return inclusionList
  where
    mkSafe (UnsafeInclusionList is n) = do
      fptr <- newForeignPtr_ (castPtr is)
      return $ DVS.unsafeFromForeignPtr fptr 0 n
{-# INLINEABLE registerInclusionList #-}

fromInclusionList :: InclusionList s -> (Ptr (), Int)
fromInclusionList is = let (p, _, _) = DVS.unsafeToForeignPtr is in
                       (castPtr $ Foreign.ForeignPtr.Unsafe.unsafeForeignPtrToPtr p, DVS.length is)

toInclusionList :: (Ptr (), Int) -> UnsafeInclusionList
toInclusionList (is, n) = UnsafeInclusionList is n

%dis inclusionList is n = <fromInclusionList/toInclusionList> (ptr is) (int n)

-- A more efficient alternative to clang_getInclusions.
-- void getInclusions(CXTranslationUnit tu, struct Inclusion** inclusionsOut, unsigned* countOut)
%fun unsafe_getInclusions :: TranslationUnit s -> IO UnsafeInclusionList
%call (translationUnit t)
%code struct Inclusion* inclusions; unsigned count;
%     getInclusions(t, &inclusions, &count);
%result (inclusionList inclusions count)

getInclusions :: ClangBase m => TranslationUnit s' -> ClangT s m (InclusionList s)
getInclusions = registerInclusionList . unsafe_getInclusions
